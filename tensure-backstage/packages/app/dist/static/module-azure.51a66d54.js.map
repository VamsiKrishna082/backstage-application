{"version":3,"file":"static/module-azure.51a66d54.js","mappings":"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","sources":["webpack://app/../../node_modules/@azure/logger/dist/browser/log.common.js","webpack://app/../../node_modules/@azure/logger/dist/browser/debug.js","webpack://app/../../node_modules/@azure/logger/dist/browser/index.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/logging.js","webpack://app/../../node_modules/@azure/identity/dist/browser/errors.js","webpack://app/../../node_modules/@azure/identity/dist/browser/constants.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/tracingContext.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/state.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/instrumenter.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/tracingClient.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/tracing.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/chainedTokenCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/defaultAzureCredential.js","webpack://app/../../node_modules/@azure/abort-controller/dist/browser/AbortError.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/createAbortablePromise.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/random.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/delay.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/object.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/error.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/bytesEncoding.common.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/sha256.common.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/uuidUtils.common.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/uuidUtils.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/checkEnvironment.js","webpack://app/../../node_modules/@azure/identity/dist/browser/msal/utils.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/pipeline.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/log.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/sanitizer.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/logPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/redirectPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgentPlatform.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/constants.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgent.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/userAgentPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/file.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/typeGuards.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/concat.common.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/multipartPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/decompressResponsePolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/helpers.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/retryStrategies/throttlingRetryStrategy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/retryStrategies/exponentialRetryStrategy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/retryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/defaultRetryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/httpHeaders.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/formDataPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/proxyPolicy.common.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/setClientRequestIdPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/agentPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/tlsPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/inspect.common.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/restError.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/tracingPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/createPipelineFromOptions.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/fetchHttpClient.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/defaultHttpClient.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/pipelineRequest.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/exponentialRetryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/systemErrorRetryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/throttlingRetryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/tokenCycler.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/bearerTokenAuthenticationPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/auxiliaryAuthenticationHeaderPolicy.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/tenantIdUtils.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/serializer.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/interfaces.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/state.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/operationHelpers.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/deserializationPolicy.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/interfaceHelpers.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/serializationPolicy.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/pipeline.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/utils.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/httpClientCache.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/urlHelpers.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/log.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/serviceClient.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/authorizeRequestOnClaimChallenge.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/authorizeRequestOnTenantChallenge.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/identityTokenEndpoint.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/utils.js","webpack://app/../../node_modules/@azure/identity/dist/browser/client/identityClient.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientSecretCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/environmentCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientCertificateCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientAssertionCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azureCliCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azureDeveloperCliCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/scopeUtils.js","webpack://app/../../node_modules/@azure/identity/dist/browser/msal/browserFlows/msalBrowserCommon.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/interactiveBrowserCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/index.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/deviceCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azurePipelinesCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/authorizationCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azurePowerShellCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/usernamePasswordCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/visualStudioCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/onBehalfOfCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/workloadIdentityCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/tokenProvider.js","webpack://app/../../node_modules/@azure/identity/dist/browser/index.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nexport function log(...args) {\n    if (args.length > 0) {\n        const firstArg = String(args[0]);\n        if (firstArg.includes(\":error\")) {\n            console.error(...args);\n        }\n        else if (firstArg.includes(\":warning\")) {\n            console.warn(...args);\n        }\n        else if (firstArg.includes(\":info\")) {\n            console.info(...args);\n        }\n        else if (firstArg.includes(\":verbose\")) {\n            console.debug(...args);\n        }\n        else {\n            console.debug(...args);\n        }\n    }\n}\n//# sourceMappingURL=log.common.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { log } from \"./log.js\";\nconst debugEnvVariable = (typeof process !== \"undefined\" && process.env && process.env.DEBUG) || undefined;\nlet enabledString;\nlet enabledNamespaces = [];\nlet skippedNamespaces = [];\nconst debuggers = [];\nif (debugEnvVariable) {\n    enable(debugEnvVariable);\n}\nconst debugObj = Object.assign((namespace) => {\n    return createDebugger(namespace);\n}, {\n    enable,\n    enabled,\n    disable,\n    log,\n});\nfunction enable(namespaces) {\n    enabledString = namespaces;\n    enabledNamespaces = [];\n    skippedNamespaces = [];\n    const wildcard = /\\*/g;\n    const namespaceList = namespaces.split(\",\").map((ns) => ns.trim().replace(wildcard, \".*?\"));\n    for (const ns of namespaceList) {\n        if (ns.startsWith(\"-\")) {\n            skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));\n        }\n        else {\n            enabledNamespaces.push(new RegExp(`^${ns}$`));\n        }\n    }\n    for (const instance of debuggers) {\n        instance.enabled = enabled(instance.namespace);\n    }\n}\nfunction enabled(namespace) {\n    if (namespace.endsWith(\"*\")) {\n        return true;\n    }\n    for (const skipped of skippedNamespaces) {\n        if (skipped.test(namespace)) {\n            return false;\n        }\n    }\n    for (const enabledNamespace of enabledNamespaces) {\n        if (enabledNamespace.test(namespace)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction disable() {\n    const result = enabledString || \"\";\n    enable(\"\");\n    return result;\n}\nfunction createDebugger(namespace) {\n    const newDebugger = Object.assign(debug, {\n        enabled: enabled(namespace),\n        destroy,\n        log: debugObj.log,\n        namespace,\n        extend,\n    });\n    function debug(...args) {\n        if (!newDebugger.enabled) {\n            return;\n        }\n        if (args.length > 0) {\n            args[0] = `${namespace} ${args[0]}`;\n        }\n        newDebugger.log(...args);\n    }\n    debuggers.push(newDebugger);\n    return newDebugger;\n}\nfunction destroy() {\n    const index = debuggers.indexOf(this);\n    if (index >= 0) {\n        debuggers.splice(index, 1);\n        return true;\n    }\n    return false;\n}\nfunction extend(namespace) {\n    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);\n    newDebugger.log = this.log;\n    return newDebugger;\n}\nexport default debugObj;\n//# sourceMappingURL=debug.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport debug from \"./debug.js\";\nconst registeredLoggers = new Set();\nconst logLevelFromEnv = (typeof process !== \"undefined\" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;\nlet azureLogLevel;\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport const AzureLogger = debug(\"azure\");\nAzureLogger.log = (...args) => {\n    debug.log(...args);\n};\nconst AZURE_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\nif (logLevelFromEnv) {\n    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n    if (isAzureLogLevel(logLevelFromEnv)) {\n        setLogLevel(logLevelFromEnv);\n    }\n    else {\n        console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(\", \")}.`);\n    }\n}\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level) {\n    if (level && !isAzureLogLevel(level)) {\n        throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(\",\")}`);\n    }\n    azureLogLevel = level;\n    const enabledNamespaces = [];\n    for (const logger of registeredLoggers) {\n        if (shouldEnable(logger)) {\n            enabledNamespaces.push(logger.namespace);\n        }\n    }\n    debug.enable(enabledNamespaces.join(\",\"));\n}\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n    return azureLogLevel;\n}\nconst levelMap = {\n    verbose: 400,\n    info: 300,\n    warning: 200,\n    error: 100,\n};\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace) {\n    const clientRootLogger = AzureLogger.extend(namespace);\n    patchLogMethod(AzureLogger, clientRootLogger);\n    return {\n        error: createLogger(clientRootLogger, \"error\"),\n        warning: createLogger(clientRootLogger, \"warning\"),\n        info: createLogger(clientRootLogger, \"info\"),\n        verbose: createLogger(clientRootLogger, \"verbose\"),\n    };\n}\nfunction patchLogMethod(parent, child) {\n    child.log = (...args) => {\n        parent.log(...args);\n    };\n}\nfunction createLogger(parent, level) {\n    const logger = Object.assign(parent.extend(level), {\n        level,\n    });\n    patchLogMethod(parent, logger);\n    if (shouldEnable(logger)) {\n        const enabledNamespaces = debug.disable();\n        debug.enable(enabledNamespaces + \",\" + logger.namespace);\n    }\n    registeredLoggers.add(logger);\n    return logger;\n}\nfunction shouldEnable(logger) {\n    return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);\n}\nfunction isAzureLogLevel(logLevel) {\n    return AZURE_LOG_LEVELS.includes(logLevel);\n}\n//# sourceMappingURL=index.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\n/**\n * The AzureLogger used for all clients within the identity package\n */\nexport const logger = createClientLogger(\"identity\");\n/**\n * Separates a list of environment variable names into a plain object with two arrays: an array of missing environment variables and another array with assigned environment variables.\n * @param supportedEnvVars - List of environment variable names\n */\nexport function processEnvVars(supportedEnvVars) {\n    return supportedEnvVars.reduce((acc, envVariable) => {\n        if (process.env[envVariable]) {\n            acc.assigned.push(envVariable);\n        }\n        else {\n            acc.missing.push(envVariable);\n        }\n        return acc;\n    }, { missing: [], assigned: [] });\n}\n/**\n * Based on a given list of environment variable names,\n * logs the environment variables currently assigned during the usage of a credential that goes by the given name.\n * @param credentialName - Name of the credential in use\n * @param supportedEnvVars - List of environment variables supported by that credential\n */\nexport function logEnvVars(credentialName, supportedEnvVars) {\n    const { assigned } = processEnvVars(supportedEnvVars);\n    logger.info(`${credentialName} => Found the following environment variables: ${assigned.join(\", \")}`);\n}\n/**\n * Formatting the success event on the credentials\n */\nexport function formatSuccess(scope) {\n    return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(\", \") : scope}.`;\n}\n/**\n * Formatting the success event on the credentials\n */\nexport function formatError(scope, error) {\n    let message = \"ERROR.\";\n    if (scope === null || scope === void 0 ? void 0 : scope.length) {\n        message += ` Scopes: ${Array.isArray(scope) ? scope.join(\", \") : scope}.`;\n    }\n    return `${message} Error message: ${typeof error === \"string\" ? error : error.message}.`;\n}\n/**\n * Generates a CredentialLoggerInstance.\n *\n * It logs with the format:\n *\n *   `[title] => [message]`\n *\n */\nexport function credentialLoggerInstance(title, parent, log = logger) {\n    const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;\n    function info(message) {\n        log.info(`${fullTitle} =>`, message);\n    }\n    function warning(message) {\n        log.warning(`${fullTitle} =>`, message);\n    }\n    function verbose(message) {\n        log.verbose(`${fullTitle} =>`, message);\n    }\n    function error(message) {\n        log.error(`${fullTitle} =>`, message);\n    }\n    return {\n        title,\n        fullTitle,\n        info,\n        warning,\n        verbose,\n        error,\n    };\n}\n/**\n * Generates a CredentialLogger, which is a logger declared at the credential's constructor, and used at any point in the credential.\n * It has all the properties of a CredentialLoggerInstance, plus other logger instances, one per method.\n *\n * It logs with the format:\n *\n *   `[title] => [message]`\n *   `[title] => getToken() => [message]`\n *\n */\nexport function credentialLogger(title, log = logger) {\n    const credLogger = credentialLoggerInstance(title, undefined, log);\n    return Object.assign(Object.assign({}, credLogger), { parent: log, getToken: credentialLoggerInstance(\"=> getToken()\", credLogger, log) });\n}\n//# sourceMappingURL=logging.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction isErrorResponse(errorResponse) {\n    return (errorResponse &&\n        typeof errorResponse.error === \"string\" &&\n        typeof errorResponse.error_description === \"string\");\n}\n/**\n * The Error.name value of an CredentialUnavailable\n */\nexport const CredentialUnavailableErrorName = \"CredentialUnavailableError\";\n/**\n * This signifies that the credential that was tried in a chained credential\n * was not available to be used as the credential. Rather than treating this as\n * an error that should halt the chain, it's caught and the chain continues\n */\nexport class CredentialUnavailableError extends Error {\n    constructor(message, options) {\n        // @ts-expect-error - TypeScript does not recognize this until we use ES2022 as the target; however, all our major runtimes do support the `cause` property\n        super(message, options);\n        this.name = CredentialUnavailableErrorName;\n    }\n}\n/**\n * The Error.name value of an AuthenticationError\n */\nexport const AuthenticationErrorName = \"AuthenticationError\";\n/**\n * Provides details about a failure to authenticate with Azure Active\n * Directory.  The `errorResponse` field contains more details about\n * the specific failure.\n */\nexport class AuthenticationError extends Error {\n    constructor(statusCode, errorBody, options) {\n        let errorResponse = {\n            error: \"unknown\",\n            errorDescription: \"An unknown error occurred and no additional details are available.\",\n        };\n        if (isErrorResponse(errorBody)) {\n            errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);\n        }\n        else if (typeof errorBody === \"string\") {\n            try {\n                // Most error responses will contain JSON-formatted error details\n                // in the response body\n                const oauthErrorResponse = JSON.parse(errorBody);\n                errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);\n            }\n            catch (e) {\n                if (statusCode === 400) {\n                    errorResponse = {\n                        error: \"invalid_request\",\n                        errorDescription: `The service indicated that the request was invalid.\\n\\n${errorBody}`,\n                    };\n                }\n                else {\n                    errorResponse = {\n                        error: \"unknown_error\",\n                        errorDescription: `An unknown error has occurred. Response body:\\n\\n${errorBody}`,\n                    };\n                }\n            }\n        }\n        else {\n            errorResponse = {\n                error: \"unknown_error\",\n                errorDescription: \"An unknown error occurred and no additional details are available.\",\n            };\n        }\n        super(`${errorResponse.error} Status code: ${statusCode}\\nMore details:\\n${errorResponse.errorDescription},`, \n        // @ts-expect-error - TypeScript does not recognize this until we use ES2022 as the target; however, all our major runtimes do support the `cause` property\n        options);\n        this.statusCode = statusCode;\n        this.errorResponse = errorResponse;\n        // Ensure that this type reports the correct name\n        this.name = AuthenticationErrorName;\n    }\n}\n/**\n * The Error.name value of an AggregateAuthenticationError\n */\nexport const AggregateAuthenticationErrorName = \"AggregateAuthenticationError\";\n/**\n * Provides an `errors` array containing {@link AuthenticationError} instance\n * for authentication failures from credentials in a {@link ChainedTokenCredential}.\n */\nexport class AggregateAuthenticationError extends Error {\n    constructor(errors, errorMessage) {\n        const errorDetail = errors.join(\"\\n\");\n        super(`${errorMessage}\\n${errorDetail}`);\n        this.errors = errors;\n        // Ensure that this type reports the correct name\n        this.name = AggregateAuthenticationErrorName;\n    }\n}\nfunction convertOAuthErrorResponseToErrorResponse(errorBody) {\n    return {\n        error: errorBody.error,\n        errorDescription: errorBody.error_description,\n        correlationId: errorBody.correlation_id,\n        errorCodes: errorBody.error_codes,\n        timestamp: errorBody.timestamp,\n        traceId: errorBody.trace_id,\n    };\n}\n/**\n * Error used to enforce authentication after trying to retrieve a token silently.\n */\nexport class AuthenticationRequiredError extends Error {\n    constructor(\n    /**\n     * Optional parameters. A message can be specified. The {@link GetTokenOptions} of the request can also be specified to more easily associate the error with the received parameters.\n     */\n    options) {\n        super(options.message, \n        // @ts-expect-error - TypeScript does not recognize this until we use ES2022 as the target; however, all our major runtimes do support the `cause` property\n        options.cause ? { cause: options.cause } : undefined);\n        this.scopes = options.scopes;\n        this.getTokenOptions = options.getTokenOptions;\n        this.name = \"AuthenticationRequiredError\";\n    }\n}\n//# sourceMappingURL=errors.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Current version of the `@azure/identity` package.\n */\nexport const SDK_VERSION = `4.9.1`;\n/**\n * The default client ID for authentication\n * @internal\n */\n// TODO: temporary - this is the Azure CLI clientID - we'll replace it when\n// Developer Sign On application is available\n// https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/Constants.cs#L9\nexport const DeveloperSignOnClientId = \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\";\n/**\n * The default tenant for authentication\n * @internal\n */\nexport const DefaultTenantId = \"common\";\n/**\n * A list of known Azure authority hosts\n */\nexport var AzureAuthorityHosts;\n(function (AzureAuthorityHosts) {\n    /**\n     * China-based Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzureChina\"] = \"https://login.chinacloudapi.cn\";\n    /**\n     * Germany-based Azure Authority Host\n     *\n     * @deprecated Microsoft Cloud Germany was closed on October 29th, 2021.\n     *\n     * */\n    AzureAuthorityHosts[\"AzureGermany\"] = \"https://login.microsoftonline.de\";\n    /**\n     * US Government Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzureGovernment\"] = \"https://login.microsoftonline.us\";\n    /**\n     * Public Cloud Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzurePublicCloud\"] = \"https://login.microsoftonline.com\";\n})(AzureAuthorityHosts || (AzureAuthorityHosts = {}));\n/**\n * @internal\n * The default authority host.\n */\nexport const DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;\n/**\n * @internal\n * The default environment host for Azure Public Cloud\n */\nexport const DefaultAuthority = \"login.microsoftonline.com\";\n/**\n * @internal\n * Allow acquiring tokens for any tenant for multi-tentant auth.\n */\nexport const ALL_TENANTS = [\"*\"];\n/**\n * @internal\n */\nexport const CACHE_CAE_SUFFIX = \"cae\";\n/**\n * @internal\n */\nexport const CACHE_NON_CAE_SUFFIX = \"nocae\";\n/**\n * @internal\n *\n * The default name for the cache persistence plugin.\n * Matches the constant defined in the cache persistence package.\n */\nexport const DEFAULT_TOKEN_CACHE_NAME = \"msal.cache\";\n//# sourceMappingURL=constants.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/** @internal */\nexport const knownContextKeys = {\n    span: Symbol.for(\"@azure/core-tracing span\"),\n    namespace: Symbol.for(\"@azure/core-tracing namespace\"),\n};\n/**\n * Creates a new {@link TracingContext} with the given options.\n * @param options - A set of known keys that may be set on the context.\n * @returns A new {@link TracingContext} with the given options.\n *\n * @internal\n */\nexport function createTracingContext(options = {}) {\n    let context = new TracingContextImpl(options.parentContext);\n    if (options.span) {\n        context = context.setValue(knownContextKeys.span, options.span);\n    }\n    if (options.namespace) {\n        context = context.setValue(knownContextKeys.namespace, options.namespace);\n    }\n    return context;\n}\n/** @internal */\nexport class TracingContextImpl {\n    constructor(initialContext) {\n        this._contextMap =\n            initialContext instanceof TracingContextImpl\n                ? new Map(initialContext._contextMap)\n                : new Map();\n    }\n    setValue(key, value) {\n        const newContext = new TracingContextImpl(this);\n        newContext._contextMap.set(key, value);\n        return newContext;\n    }\n    getValue(key) {\n        return this._contextMap.get(key);\n    }\n    deleteValue(key) {\n        const newContext = new TracingContextImpl(this);\n        newContext._contextMap.delete(key);\n        return newContext;\n    }\n}\n//# sourceMappingURL=tracingContext.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Browser-only implementation of the module's state. The browser esm variant will not load the commonjs state, so we do not need to share state between the two.\n */\nexport const state = {\n    instrumenterImplementation: undefined,\n};\n//# sourceMappingURL=state-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTracingContext } from \"./tracingContext.js\";\nimport { state } from \"./state.js\";\nexport function createDefaultTracingSpan() {\n    return {\n        end: () => {\n            // noop\n        },\n        isRecording: () => false,\n        recordException: () => {\n            // noop\n        },\n        setAttribute: () => {\n            // noop\n        },\n        setStatus: () => {\n            // noop\n        },\n        addEvent: () => {\n            // noop\n        },\n    };\n}\nexport function createDefaultInstrumenter() {\n    return {\n        createRequestHeaders: () => {\n            return {};\n        },\n        parseTraceparentHeader: () => {\n            return undefined;\n        },\n        startSpan: (_name, spanOptions) => {\n            return {\n                span: createDefaultTracingSpan(),\n                tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext }),\n            };\n        },\n        withContext(_context, callback, ...callbackArgs) {\n            return callback(...callbackArgs);\n        },\n    };\n}\n/**\n * Extends the Azure SDK with support for a given instrumenter implementation.\n *\n * @param instrumenter - The instrumenter implementation to use.\n */\nexport function useInstrumenter(instrumenter) {\n    state.instrumenterImplementation = instrumenter;\n}\n/**\n * Gets the currently set instrumenter, a No-Op instrumenter by default.\n *\n * @returns The currently set instrumenter\n */\nexport function getInstrumenter() {\n    if (!state.instrumenterImplementation) {\n        state.instrumenterImplementation = createDefaultInstrumenter();\n    }\n    return state.instrumenterImplementation;\n}\n//# sourceMappingURL=instrumenter.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options) {\n    const { namespace, packageName, packageVersion } = options;\n    function startSpan(name, operationOptions, spanOptions) {\n        var _a;\n        const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName: packageName, packageVersion: packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext }));\n        let tracingContext = startSpanResult.tracingContext;\n        const span = startSpanResult.span;\n        if (!tracingContext.getValue(knownContextKeys.namespace)) {\n            tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n        }\n        span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n        const updatedOptions = Object.assign({}, operationOptions, {\n            tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext }),\n        });\n        return {\n            span,\n            updatedOptions,\n        };\n    }\n    async function withSpan(name, operationOptions, callback, spanOptions) {\n        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);\n        try {\n            const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));\n            span.setStatus({ status: \"success\" });\n            return result;\n        }\n        catch (err) {\n            span.setStatus({ status: \"error\", error: err });\n            throw err;\n        }\n        finally {\n            span.end();\n        }\n    }\n    function withContext(context, callback, ...callbackArgs) {\n        return getInstrumenter().withContext(context, callback, ...callbackArgs);\n    }\n    /**\n     * Parses a traceparent header value into a span identifier.\n     *\n     * @param traceparentHeader - The traceparent header to parse.\n     * @returns An implementation-specific identifier for the span.\n     */\n    function parseTraceparentHeader(traceparentHeader) {\n        return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n    }\n    /**\n     * Creates a set of request headers to propagate tracing information to a backend.\n     *\n     * @param tracingContext - The context containing the span to serialize.\n     * @returns The set of headers to add to a request.\n     */\n    function createRequestHeaders(tracingContext) {\n        return getInstrumenter().createRequestHeaders(tracingContext);\n    }\n    return {\n        startSpan,\n        withSpan,\n        withContext,\n        parseTraceparentHeader,\n        createRequestHeaders,\n    };\n}\n//# sourceMappingURL=tracingClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { SDK_VERSION } from \"../constants.js\";\nimport { createTracingClient } from \"@azure/core-tracing\";\n/**\n * Creates a span using the global tracer.\n * @internal\n */\nexport const tracingClient = createTracingClient({\n    namespace: \"Microsoft.AAD\",\n    packageName: \"@azure/identity\",\n    packageVersion: SDK_VERSION,\n});\n//# sourceMappingURL=tracing.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors.js\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging.js\";\nimport { tracingClient } from \"../util/tracing.js\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order until\n * one of the getToken methods returns an access token. For more information, see\n * [ChainedTokenCredential overview](https://aka.ms/azsdk/js/identity/credential-chains#use-chainedtokencredential-for-granularity).\n */\nexport class ChainedTokenCredential {\n    /**\n     * Creates an instance of ChainedTokenCredential using the given credentials.\n     *\n     * @param sources - `TokenCredential` implementations to be tried in order.\n     *\n     * Example usage:\n     * ```ts snippet:chained_token_credential_example\n     * import { ClientSecretCredential, ChainedTokenCredential } from \"@azure/identity\";\n     *\n     * const tenantId = \"<tenant-id>\";\n     * const clientId = \"<client-id>\";\n     * const clientSecret = \"<client-secret>\";\n     * const anotherClientId = \"<another-client-id>\";\n     * const anotherSecret = \"<another-client-secret>\";\n     *\n     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n     *\n     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n     * ```\n     */\n    constructor(...sources) {\n        this._sources = [];\n        this._sources = sources;\n    }\n    /**\n     * Returns the first access token returned by one of the chained\n     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n     * when one or more credentials throws an {@link AuthenticationError} and\n     * no credentials have returned an access token.\n     *\n     * This method is called automatically by Azure SDK client libraries. You may call this method\n     * directly, but you must also handle token caching and token refreshing.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                `TokenCredential` implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        const { token } = await this.getTokenInternal(scopes, options);\n        return token;\n    }\n    async getTokenInternal(scopes, options = {}) {\n        let token = null;\n        let successfulCredential;\n        const errors = [];\n        return tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, async (updatedOptions) => {\n            for (let i = 0; i < this._sources.length && token === null; i++) {\n                try {\n                    token = await this._sources[i].getToken(scopes, updatedOptions);\n                    successfulCredential = this._sources[i];\n                }\n                catch (err) {\n                    if (err.name === \"CredentialUnavailableError\" ||\n                        err.name === \"AuthenticationRequiredError\") {\n                        errors.push(err);\n                    }\n                    else {\n                        logger.getToken.info(formatError(scopes, err));\n                        throw err;\n                    }\n                }\n            }\n            if (!token && errors.length > 0) {\n                const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n            }\n            logger.getToken.info(`Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`);\n            if (token === null) {\n                throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n            }\n            return { token, successfulCredential };\n        });\n    }\n}\n//# sourceMappingURL=chainedTokenCredential.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { ChainedTokenCredential } from \"./chainedTokenCredential.js\";\nconst BrowserNotSupportedError = new Error(\"DefaultAzureCredential is not supported in the browser. Use InteractiveBrowserCredential instead.\");\nconst logger = credentialLogger(\"DefaultAzureCredential\");\n/**\n * Provides a default {@link ChainedTokenCredential} configuration for\n * applications that will be deployed to Azure.\n *\n * Only available in Node.js.\n */\nexport class DefaultAzureCredential extends ChainedTokenCredential {\n    /**\n     * Creates an instance of the DefaultAzureCredential class.\n     *\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(_tokenCredentialOptions) {\n        super();\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=defaultAzureCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * This error is thrown when an asynchronous operation has been aborted.\n * Check for this error by testing the `name` that the name property of the\n * error matches `\"AbortError\"`.\n *\n * @example\n * ```ts\n * const controller = new AbortController();\n * controller.abort();\n * try {\n *   doAsyncWork(controller.signal)\n * } catch (e) {\n *   if (e.name === 'AbortError') {\n *     // handle abort error here.\n *   }\n * }\n * ```\n */\nexport class AbortError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"AbortError\";\n    }\n}\n//# sourceMappingURL=AbortError.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"@azure/abort-controller\";\n/**\n * Creates an abortable promise.\n * @param buildPromise - A function that takes the resolve and reject functions as parameters.\n * @param options - The options for the abortable promise.\n * @returns A promise that can be aborted.\n */\nexport function createAbortablePromise(buildPromise, options) {\n    const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};\n    return new Promise((resolve, reject) => {\n        function rejectOnAbort() {\n            reject(new AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : \"The operation was aborted.\"));\n        }\n        function removeListeners() {\n            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n        function onAbort() {\n            cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();\n            removeListeners();\n            rejectOnAbort();\n        }\n        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n            return rejectOnAbort();\n        }\n        try {\n            buildPromise((x) => {\n                removeListeners();\n                resolve(x);\n            }, (x) => {\n                removeListeners();\n                reject(x);\n            });\n        }\n        catch (err) {\n            reject(err);\n        }\n        abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", onAbort);\n    });\n}\n//# sourceMappingURL=createAbortablePromise.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Returns a random integer value between a lower and upper bound,\n * inclusive of both bounds.\n * Note that this uses Math.random and isn't secure. If you need to use\n * this for any kind of security purpose, find a better source of random.\n * @param min - The smallest integer value allowed.\n * @param max - The largest integer value allowed.\n */\nexport function getRandomIntegerInclusive(min, max) {\n    // Make sure inputs are integers.\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    // Pick a random offset from zero to the size of the range.\n    // Since Math.random() can never return 1, we have to make the range one larger\n    // in order to be inclusive of the maximum value after we take the floor.\n    const offset = Math.floor(Math.random() * (max - min + 1));\n    return offset + min;\n}\n//# sourceMappingURL=random.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createAbortablePromise } from \"./createAbortablePromise.js\";\nimport { getRandomIntegerInclusive } from \"./random.js\";\nconst StandardAbortMessage = \"The delay was aborted.\";\n/**\n * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.\n * @param timeInMs - The number of milliseconds to be delayed.\n * @param options - The options for delay - currently abort options\n * @returns Promise that is resolved after timeInMs\n */\nexport function delay(timeInMs, options) {\n    let token;\n    const { abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};\n    return createAbortablePromise((resolve) => {\n        token = setTimeout(resolve, timeInMs);\n    }, {\n        cleanupBeforeAbort: () => clearTimeout(token),\n        abortSignal,\n        abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage,\n    });\n}\n/**\n * Calculates the delay interval for retry attempts using exponential delay with jitter.\n * @param retryAttempt - The current retry attempt number.\n * @param config - The exponential retry configuration.\n * @returns An object containing the calculated retry delay.\n */\nexport function calculateRetryDelay(retryAttempt, config) {\n    // Exponentially increase the delay each time\n    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);\n    // Don't let the delay exceed the maximum\n    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);\n    // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n    // that retries across multiple clients don't occur simultaneously.\n    const retryAfterInMs = clampedDelay / 2 + getRandomIntegerInclusive(0, clampedDelay / 2);\n    return { retryAfterInMs };\n}\n//# sourceMappingURL=delay.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Helper to determine when an input is a generic JS object.\n * @returns true when input is an object type that is not null, Array, RegExp, or Date.\n */\nexport function isObject(input) {\n    return (typeof input === \"object\" &&\n        input !== null &&\n        !Array.isArray(input) &&\n        !(input instanceof RegExp) &&\n        !(input instanceof Date));\n}\n//# sourceMappingURL=object.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isObject } from \"./object.js\";\n/**\n * Typeguard for an error object shape (has name and message)\n * @param e - Something caught by a catch clause.\n */\nexport function isError(e) {\n    if (isObject(e)) {\n        const hasName = typeof e.name === \"string\";\n        const hasMessage = typeof e.message === \"string\";\n        return hasName && hasMessage;\n    }\n    return false;\n}\n/**\n * Given what is thought to be an error object, return the message if possible.\n * If the message is missing, returns a stringified version of the input.\n * @param e - Something thrown from a try block\n * @returns The error message or a string of the input\n */\nexport function getErrorMessage(e) {\n    if (isError(e)) {\n        return e.message;\n    }\n    else {\n        let stringified;\n        try {\n            if (typeof e === \"object\" && e) {\n                stringified = JSON.stringify(e);\n            }\n            else {\n                stringified = String(e);\n            }\n        }\n        catch (err) {\n            stringified = \"[unable to stringify input]\";\n        }\n        return `Unknown error ${stringified}`;\n    }\n}\n//# sourceMappingURL=error.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * The helper that transforms bytes with specific character encoding into string\n * @param bytes - the uint8array bytes\n * @param format - the format we use to encode the byte\n * @returns a string of the encoded string\n */\nexport function uint8ArrayToString(bytes, format) {\n    switch (format) {\n        case \"utf-8\":\n            return uint8ArrayToUtf8String(bytes);\n        case \"base64\":\n            return uint8ArrayToBase64(bytes);\n        case \"base64url\":\n            return uint8ArrayToBase64Url(bytes);\n        case \"hex\":\n            return uint8ArrayToHexString(bytes);\n    }\n}\n/**\n * The helper that transforms string to specific character encoded bytes array.\n * @param value - the string to be converted\n * @param format - the format we use to decode the value\n * @returns a uint8array\n */\nexport function stringToUint8Array(value, format) {\n    switch (format) {\n        case \"utf-8\":\n            return utf8StringToUint8Array(value);\n        case \"base64\":\n            return base64ToUint8Array(value);\n        case \"base64url\":\n            return base64UrlToUint8Array(value);\n        case \"hex\":\n            return hexStringToUint8Array(value);\n    }\n}\n/**\n * Decodes a Uint8Array into a Base64 string.\n * @internal\n */\nexport function uint8ArrayToBase64(bytes) {\n    return btoa([...bytes].map((x) => String.fromCharCode(x)).join(\"\"));\n}\n/**\n * Decodes a Uint8Array into a Base64Url string.\n * @internal\n */\nexport function uint8ArrayToBase64Url(bytes) {\n    return uint8ArrayToBase64(bytes).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n/**\n * Decodes a Uint8Array into a javascript string.\n * @internal\n */\nexport function uint8ArrayToUtf8String(bytes) {\n    const decoder = new TextDecoder();\n    const dataString = decoder.decode(bytes);\n    return dataString;\n}\n/**\n * Decodes a Uint8Array into a hex string\n * @internal\n */\nexport function uint8ArrayToHexString(bytes) {\n    return [...bytes].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n}\n/**\n * Encodes a JavaScript string into a Uint8Array.\n * @internal\n */\nexport function utf8StringToUint8Array(value) {\n    return new TextEncoder().encode(value);\n}\n/**\n * Encodes a Base64 string into a Uint8Array.\n * @internal\n */\nexport function base64ToUint8Array(value) {\n    return new Uint8Array([...atob(value)].map((x) => x.charCodeAt(0)));\n}\n/**\n * Encodes a Base64Url string into a Uint8Array.\n * @internal\n */\nexport function base64UrlToUint8Array(value) {\n    const base64String = value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    return base64ToUint8Array(base64String);\n}\nconst hexDigits = new Set(\"0123456789abcdefABCDEF\");\n/**\n * Encodes a hex string into a Uint8Array\n * @internal\n */\nexport function hexStringToUint8Array(value) {\n    // If value has odd length, the last character will be ignored, consistent with NodeJS Buffer behavior\n    const bytes = new Uint8Array(value.length / 2);\n    for (let i = 0; i < value.length / 2; ++i) {\n        const highNibble = value[2 * i];\n        const lowNibble = value[2 * i + 1];\n        if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {\n            // Replicate Node Buffer behavior by exiting early when we encounter an invalid byte\n            return bytes.slice(0, i);\n        }\n        bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);\n    }\n    return bytes;\n}\n//# sourceMappingURL=bytesEncoding.common.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { stringToUint8Array, uint8ArrayToString } from \"./bytesEncoding.js\";\nlet subtleCrypto;\n/**\n * Returns a cached reference to the Web API crypto.subtle object.\n * @internal\n */\nfunction getCrypto() {\n    if (subtleCrypto) {\n        return subtleCrypto;\n    }\n    if (!self.crypto || !self.crypto.subtle) {\n        throw new Error(\"Your browser environment does not support cryptography functions.\");\n    }\n    subtleCrypto = self.crypto.subtle;\n    return subtleCrypto;\n}\n/**\n * Generates a SHA-256 HMAC signature.\n * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.\n * @param stringToSign - The data to be signed.\n * @param encoding - The textual encoding to use for the returned HMAC digest.\n */\nexport async function computeSha256Hmac(key, stringToSign, encoding) {\n    const crypto = getCrypto();\n    const keyBytes = stringToUint8Array(key, \"base64\");\n    const stringToSignBytes = stringToUint8Array(stringToSign, \"utf-8\");\n    const cryptoKey = await crypto.importKey(\"raw\", keyBytes, {\n        name: \"HMAC\",\n        hash: { name: \"SHA-256\" },\n    }, false, [\"sign\"]);\n    const signature = await crypto.sign({\n        name: \"HMAC\",\n        hash: { name: \"SHA-256\" },\n    }, cryptoKey, stringToSignBytes);\n    return uint8ArrayToString(new Uint8Array(signature), encoding);\n}\n/**\n * Generates a SHA-256 hash.\n * @param content - The data to be included in the hash.\n * @param encoding - The textual encoding to use for the returned hash.\n */\nexport async function computeSha256Hash(content, encoding) {\n    const contentBytes = stringToUint8Array(content, \"utf-8\");\n    const digest = await getCrypto().digest({ name: \"SHA-256\" }, contentBytes);\n    return uint8ArrayToString(new Uint8Array(digest), encoding);\n}\n//# sourceMappingURL=sha256.common.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function generateUUID() {\n    let uuid = \"\";\n    for (let i = 0; i < 32; i++) {\n        // Generate a random number between 0 and 15\n        const randomNumber = Math.floor(Math.random() * 16);\n        // Set the UUID version to 4 in the 13th position\n        if (i === 12) {\n            uuid += \"4\";\n        }\n        else if (i === 16) {\n            // Set the UUID variant to \"10\" in the 17th position\n            uuid += (randomNumber & 0x3) | 0x8;\n        }\n        else {\n            // Add a random hexadecimal digit to the UUID string\n            uuid += randomNumber.toString(16);\n        }\n        // Add hyphens to the UUID string at the appropriate positions\n        if (i === 7 || i === 11 || i === 15 || i === 19) {\n            uuid += \"-\";\n        }\n    }\n    return uuid;\n}\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function randomUUID() {\n    return generateUUID();\n}\n//# sourceMappingURL=uuidUtils.common.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar _a;\nimport { generateUUID } from \"./uuidUtils.common.js\";\n// NOTE: This could be undefined if not used in a secure context\nconst uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === \"function\"\n    ? globalThis.crypto.randomUUID.bind(globalThis.crypto)\n    : generateUUID;\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function randomUUID() {\n    return uuidFunction();\n}\n//# sourceMappingURL=uuidUtils-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nvar _a, _b, _c, _d;\n/**\n * A constant that indicates whether the environment the code is running is a Web Browser.\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-no-window\nexport const isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n/**\n * A constant that indicates whether the environment the code is running is a Web Worker.\n */\nexport const isWebWorker = typeof self === \"object\" &&\n    typeof (self === null || self === void 0 ? void 0 : self.importScripts) === \"function\" &&\n    (((_a = self.constructor) === null || _a === void 0 ? void 0 : _a.name) === \"DedicatedWorkerGlobalScope\" ||\n        ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === \"ServiceWorkerGlobalScope\" ||\n        ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === \"SharedWorkerGlobalScope\");\n/**\n * A constant that indicates whether the environment the code is running is Deno.\n */\nexport const isDeno = typeof Deno !== \"undefined\" &&\n    typeof Deno.version !== \"undefined\" &&\n    typeof Deno.version.deno !== \"undefined\";\n/**\n * A constant that indicates whether the environment the code is running is Bun.sh.\n */\nexport const isBun = typeof Bun !== \"undefined\" && typeof Bun.version !== \"undefined\";\n/**\n * A constant that indicates whether the environment the code is running is a Node.js compatible environment.\n */\nexport const isNodeLike = typeof globalThis.process !== \"undefined\" &&\n    Boolean(globalThis.process.version) &&\n    Boolean((_d = globalThis.process.versions) === null || _d === void 0 ? void 0 : _d.node);\n/**\n * A constant that indicates whether the environment the code is running is a Node.js compatible environment.\n * @deprecated Use `isNodeLike` instead.\n */\nexport const isNode = isNodeLike;\n/**\n * A constant that indicates whether the environment the code is running is Node.JS.\n */\nexport const isNodeRuntime = isNodeLike && !isBun && !isDeno;\n/**\n * A constant that indicates whether the environment the code is running is in React-Native.\n */\n// https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js\nexport const isReactNative = typeof navigator !== \"undefined\" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === \"ReactNative\";\n//# sourceMappingURL=checkEnvironment.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../errors.js\";\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { DefaultAuthority, DefaultAuthorityHost, DefaultTenantId } from \"../constants.js\";\nimport { randomUUID as coreRandomUUID, isNode, isNodeLike } from \"@azure/core-util\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { msalCommon } from \"./msal.js\";\n/**\n * @internal\n */\nconst logger = credentialLogger(\"IdentityUtils\");\n/**\n * Latest AuthenticationRecord version\n * @internal\n */\nconst LatestAuthenticationRecordVersion = \"1.0\";\n/**\n * Ensures the validity of the MSAL token\n * @internal\n */\nexport function ensureValidMsalToken(scopes, msalToken, getTokenOptions) {\n    const error = (message) => {\n        logger.getToken.info(message);\n        return new AuthenticationRequiredError({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            getTokenOptions,\n            message,\n        });\n    };\n    if (!msalToken) {\n        throw error(\"No response\");\n    }\n    if (!msalToken.expiresOn) {\n        throw error(`Response had no \"expiresOn\" property.`);\n    }\n    if (!msalToken.accessToken) {\n        throw error(`Response had no \"accessToken\" property.`);\n    }\n}\n/**\n * Returns the authority host from either the options bag or the AZURE_AUTHORITY_HOST environment variable.\n *\n * Defaults to {@link DefaultAuthorityHost}.\n * @internal\n */\nexport function getAuthorityHost(options) {\n    let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n    if (!authorityHost && isNodeLike) {\n        authorityHost = process.env.AZURE_AUTHORITY_HOST;\n    }\n    return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * Generates a valid authority by combining a host with a tenantId.\n * @internal\n */\nexport function getAuthority(tenantId, host) {\n    if (!host) {\n        host = DefaultAuthorityHost;\n    }\n    if (new RegExp(`${tenantId}/?$`).test(host)) {\n        return host;\n    }\n    if (host.endsWith(\"/\")) {\n        return host + tenantId;\n    }\n    else {\n        return `${host}/${tenantId}`;\n    }\n}\n/**\n * Generates the known authorities.\n * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.\n * For that reason, we have to force MSAL to disable validating the authority\n * by sending it within the known authorities in the MSAL configuration.\n * @internal\n */\nexport function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {\n    if ((tenantId === \"adfs\" && authorityHost) || disableInstanceDiscovery) {\n        return [authorityHost];\n    }\n    return [];\n}\n/**\n * Generates a logger that can be passed to the MSAL clients.\n * @param credLogger - The logger of the credential.\n * @internal\n */\nexport const defaultLoggerCallback = (credLogger, platform = isNode ? \"Node\" : \"Browser\") => (level, message, containsPii) => {\n    if (containsPii) {\n        return;\n    }\n    switch (level) {\n        case msalCommon.LogLevel.Error:\n            credLogger.info(`MSAL ${platform} V2 error: ${message}`);\n            return;\n        case msalCommon.LogLevel.Info:\n            credLogger.info(`MSAL ${platform} V2 info message: ${message}`);\n            return;\n        case msalCommon.LogLevel.Verbose:\n            credLogger.info(`MSAL ${platform} V2 verbose message: ${message}`);\n            return;\n        case msalCommon.LogLevel.Warning:\n            credLogger.info(`MSAL ${platform} V2 warning: ${message}`);\n            return;\n    }\n};\n/**\n * @internal\n */\nexport function getMSALLogLevel(logLevel) {\n    switch (logLevel) {\n        case \"error\":\n            return msalCommon.LogLevel.Error;\n        case \"info\":\n            return msalCommon.LogLevel.Info;\n        case \"verbose\":\n            return msalCommon.LogLevel.Verbose;\n        case \"warning\":\n            return msalCommon.LogLevel.Warning;\n        default:\n            // default msal logging level should be Info\n            return msalCommon.LogLevel.Info;\n    }\n}\n/**\n * Wraps core-util's randomUUID in order to allow for mocking in tests.\n * This prepares the library for the upcoming core-util update to ESM.\n *\n * @internal\n * @returns A string containing a random UUID\n */\nexport function randomUUID() {\n    return coreRandomUUID();\n}\n/**\n * Handles MSAL errors.\n */\nexport function handleMsalError(scopes, error, getTokenOptions) {\n    if (error.name === \"AuthError\" ||\n        error.name === \"ClientAuthError\" ||\n        error.name === \"BrowserAuthError\") {\n        const msalError = error;\n        switch (msalError.errorCode) {\n            case \"endpoints_resolution_error\":\n                logger.info(formatError(scopes, error.message));\n                return new CredentialUnavailableError(error.message);\n            case \"device_code_polling_cancelled\":\n                return new AbortError(\"The authentication has been aborted by the caller.\");\n            case \"consent_required\":\n            case \"interaction_required\":\n            case \"login_required\":\n                logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));\n                break;\n            default:\n                logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));\n                break;\n        }\n    }\n    if (error.name === \"ClientConfigurationError\" ||\n        error.name === \"BrowserConfigurationAuthError\" ||\n        error.name === \"AbortError\" ||\n        error.name === \"AuthenticationError\") {\n        return error;\n    }\n    if (error.name === \"NativeAuthError\") {\n        logger.info(formatError(scopes, `Error from the native broker: ${error.message} with status code: ${error.statusCode}`));\n        return error;\n    }\n    return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });\n}\n// transformations\nexport function publicToMsal(account) {\n    return {\n        localAccountId: account.homeAccountId,\n        environment: account.authority,\n        username: account.username,\n        homeAccountId: account.homeAccountId,\n        tenantId: account.tenantId,\n    };\n}\nexport function msalToPublic(clientId, account) {\n    var _a;\n    const record = {\n        authority: (_a = account.environment) !== null && _a !== void 0 ? _a : DefaultAuthority,\n        homeAccountId: account.homeAccountId,\n        tenantId: account.tenantId || DefaultTenantId,\n        username: account.username,\n        clientId,\n        version: LatestAuthenticationRecordVersion,\n    };\n    return record;\n}\n/**\n * Serializes an `AuthenticationRecord` into a string.\n *\n * The output of a serialized authentication record will contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.\n */\nexport function serializeAuthenticationRecord(record) {\n    return JSON.stringify(record);\n}\n/**\n * Deserializes a previously serialized authentication record from a string into an object.\n *\n * The input string must contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * If the version we receive is unsupported, an error will be thrown.\n *\n * At the moment, the only available version is: \"1.0\", which is always set when the authentication record is serialized.\n *\n * @param serializedRecord - Authentication record previously serialized into string.\n * @returns AuthenticationRecord.\n */\nexport function deserializeAuthenticationRecord(serializedRecord) {\n    const parsed = JSON.parse(serializedRecord);\n    if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {\n        throw Error(\"Unsupported AuthenticationRecord version\");\n    }\n    return parsed;\n}\n//# sourceMappingURL=utils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nconst ValidPhaseNames = new Set([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline {\n    constructor(policies) {\n        var _a;\n        this._policies = [];\n        this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];\n        this._orderedPolicies = undefined;\n    }\n    addPolicy(policy, options = {}) {\n        if (options.phase && options.afterPhase) {\n            throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n        }\n        if (options.phase && !ValidPhaseNames.has(options.phase)) {\n            throw new Error(`Invalid phase name: ${options.phase}`);\n        }\n        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n            throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n        }\n        this._policies.push({\n            policy,\n            options,\n        });\n        this._orderedPolicies = undefined;\n    }\n    removePolicy(options) {\n        const removedPolicies = [];\n        this._policies = this._policies.filter((policyDescriptor) => {\n            if ((options.name && policyDescriptor.policy.name === options.name) ||\n                (options.phase && policyDescriptor.options.phase === options.phase)) {\n                removedPolicies.push(policyDescriptor.policy);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n        this._orderedPolicies = undefined;\n        return removedPolicies;\n    }\n    sendRequest(httpClient, request) {\n        const policies = this.getOrderedPolicies();\n        const pipeline = policies.reduceRight((next, policy) => {\n            return (req) => {\n                return policy.sendRequest(req, next);\n            };\n        }, (req) => httpClient.sendRequest(req));\n        return pipeline(request);\n    }\n    getOrderedPolicies() {\n        if (!this._orderedPolicies) {\n            this._orderedPolicies = this.orderPolicies();\n        }\n        return this._orderedPolicies;\n    }\n    clone() {\n        return new HttpPipeline(this._policies);\n    }\n    static create() {\n        return new HttpPipeline();\n    }\n    orderPolicies() {\n        /**\n         * The goal of this method is to reliably order pipeline policies\n         * based on their declared requirements when they were added.\n         *\n         * Order is first determined by phase:\n         *\n         * 1. Serialize Phase\n         * 2. Policies not in a phase\n         * 3. Deserialize Phase\n         * 4. Retry Phase\n         * 5. Sign Phase\n         *\n         * Within each phase, policies are executed in the order\n         * they were added unless they were specified to execute\n         * before/after other policies or after a particular phase.\n         *\n         * To determine the final order, we will walk the policy list\n         * in phase order multiple times until all dependencies are\n         * satisfied.\n         *\n         * `afterPolicies` are the set of policies that must be\n         * executed before a given policy. This requirement is\n         * considered satisfied when each of the listed policies\n         * have been scheduled.\n         *\n         * `beforePolicies` are the set of policies that must be\n         * executed after a given policy. Since this dependency\n         * can be expressed by converting it into a equivalent\n         * `afterPolicies` declarations, they are normalized\n         * into that form for simplicity.\n         *\n         * An `afterPhase` dependency is considered satisfied when all\n         * policies in that phase have scheduled.\n         *\n         */\n        const result = [];\n        // Track all policies we know about.\n        const policyMap = new Map();\n        function createPhase(name) {\n            return {\n                name,\n                policies: new Set(),\n                hasRun: false,\n                hasAfterPolicies: false,\n            };\n        }\n        // Track policies for each phase.\n        const serializePhase = createPhase(\"Serialize\");\n        const noPhase = createPhase(\"None\");\n        const deserializePhase = createPhase(\"Deserialize\");\n        const retryPhase = createPhase(\"Retry\");\n        const signPhase = createPhase(\"Sign\");\n        // a list of phases in order\n        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n        // Small helper function to map phase name to each Phase\n        function getPhase(phase) {\n            if (phase === \"Retry\") {\n                return retryPhase;\n            }\n            else if (phase === \"Serialize\") {\n                return serializePhase;\n            }\n            else if (phase === \"Deserialize\") {\n                return deserializePhase;\n            }\n            else if (phase === \"Sign\") {\n                return signPhase;\n            }\n            else {\n                return noPhase;\n            }\n        }\n        // First walk each policy and create a node to track metadata.\n        for (const descriptor of this._policies) {\n            const policy = descriptor.policy;\n            const options = descriptor.options;\n            const policyName = policy.name;\n            if (policyMap.has(policyName)) {\n                throw new Error(\"Duplicate policy names not allowed in pipeline\");\n            }\n            const node = {\n                policy,\n                dependsOn: new Set(),\n                dependants: new Set(),\n            };\n            if (options.afterPhase) {\n                node.afterPhase = getPhase(options.afterPhase);\n                node.afterPhase.hasAfterPolicies = true;\n            }\n            policyMap.set(policyName, node);\n            const phase = getPhase(options.phase);\n            phase.policies.add(node);\n        }\n        // Now that each policy has a node, connect dependency references.\n        for (const descriptor of this._policies) {\n            const { policy, options } = descriptor;\n            const policyName = policy.name;\n            const node = policyMap.get(policyName);\n            if (!node) {\n                throw new Error(`Missing node for policy ${policyName}`);\n            }\n            if (options.afterPolicies) {\n                for (const afterPolicyName of options.afterPolicies) {\n                    const afterNode = policyMap.get(afterPolicyName);\n                    if (afterNode) {\n                        // Linking in both directions helps later\n                        // when we want to notify dependants.\n                        node.dependsOn.add(afterNode);\n                        afterNode.dependants.add(node);\n                    }\n                }\n            }\n            if (options.beforePolicies) {\n                for (const beforePolicyName of options.beforePolicies) {\n                    const beforeNode = policyMap.get(beforePolicyName);\n                    if (beforeNode) {\n                        // To execute before another node, make it\n                        // depend on the current node.\n                        beforeNode.dependsOn.add(node);\n                        node.dependants.add(beforeNode);\n                    }\n                }\n            }\n        }\n        function walkPhase(phase) {\n            phase.hasRun = true;\n            // Sets iterate in insertion order\n            for (const node of phase.policies) {\n                if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n                    // If this node is waiting on a phase to complete,\n                    // we need to skip it for now.\n                    // Even if the phase is empty, we should wait for it\n                    // to be walked to avoid re-ordering policies.\n                    continue;\n                }\n                if (node.dependsOn.size === 0) {\n                    // If there's nothing else we're waiting for, we can\n                    // add this policy to the result list.\n                    result.push(node.policy);\n                    // Notify anything that depends on this policy that\n                    // the policy has been scheduled.\n                    for (const dependant of node.dependants) {\n                        dependant.dependsOn.delete(node);\n                    }\n                    policyMap.delete(node.policy.name);\n                    phase.policies.delete(node);\n                }\n            }\n        }\n        function walkPhases() {\n            for (const phase of orderedPhases) {\n                walkPhase(phase);\n                // if the phase isn't complete\n                if (phase.policies.size > 0 && phase !== noPhase) {\n                    if (!noPhase.hasRun) {\n                        // Try running noPhase to see if that unblocks this phase next tick.\n                        // This can happen if a phase that happens before noPhase\n                        // is waiting on a noPhase policy to complete.\n                        walkPhase(noPhase);\n                    }\n                    // Don't proceed to the next phase until this phase finishes.\n                    return;\n                }\n                if (phase.hasAfterPolicies) {\n                    // Run any policies unblocked by this phase\n                    walkPhase(noPhase);\n                }\n            }\n        }\n        // Iterate until we've put every node in the result list.\n        let iteration = 0;\n        while (policyMap.size > 0) {\n            iteration++;\n            const initialResultLength = result.length;\n            // Keep walking each phase in order until we can order every node.\n            walkPhases();\n            // The result list *should* get at least one larger each time\n            // after the first full pass.\n            // Otherwise, we're going to loop forever.\n            if (result.length <= initialResultLength && iteration > 1) {\n                throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n            }\n        }\n        return result;\n    }\n}\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline() {\n    return HttpPipeline.create();\n}\n//# sourceMappingURL=pipeline.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-rest-pipeline\");\n//# sourceMappingURL=log.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isObject } from \"@azure/core-util\";\nconst RedactedString = \"REDACTED\";\n// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts\nconst defaultAllowedHeaderNames = [\n    \"x-ms-client-request-id\",\n    \"x-ms-return-client-request-id\",\n    \"x-ms-useragent\",\n    \"x-ms-correlation-request-id\",\n    \"x-ms-request-id\",\n    \"client-request-id\",\n    \"ms-cv\",\n    \"return-client-request-id\",\n    \"traceparent\",\n    \"Access-Control-Allow-Credentials\",\n    \"Access-Control-Allow-Headers\",\n    \"Access-Control-Allow-Methods\",\n    \"Access-Control-Allow-Origin\",\n    \"Access-Control-Expose-Headers\",\n    \"Access-Control-Max-Age\",\n    \"Access-Control-Request-Headers\",\n    \"Access-Control-Request-Method\",\n    \"Origin\",\n    \"Accept\",\n    \"Accept-Encoding\",\n    \"Cache-Control\",\n    \"Connection\",\n    \"Content-Length\",\n    \"Content-Type\",\n    \"Date\",\n    \"ETag\",\n    \"Expires\",\n    \"If-Match\",\n    \"If-Modified-Since\",\n    \"If-None-Match\",\n    \"If-Unmodified-Since\",\n    \"Last-Modified\",\n    \"Pragma\",\n    \"Request-Id\",\n    \"Retry-After\",\n    \"Server\",\n    \"Transfer-Encoding\",\n    \"User-Agent\",\n    \"WWW-Authenticate\",\n];\nconst defaultAllowedQueryParameters = [\"api-version\"];\n/**\n * @internal\n */\nexport class Sanitizer {\n    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [], } = {}) {\n        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);\n        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);\n        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));\n        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));\n    }\n    sanitize(obj) {\n        const seen = new Set();\n        return JSON.stringify(obj, (key, value) => {\n            // Ensure Errors include their interesting non-enumerable members\n            if (value instanceof Error) {\n                return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });\n            }\n            if (key === \"headers\") {\n                return this.sanitizeHeaders(value);\n            }\n            else if (key === \"url\") {\n                return this.sanitizeUrl(value);\n            }\n            else if (key === \"query\") {\n                return this.sanitizeQuery(value);\n            }\n            else if (key === \"body\") {\n                // Don't log the request body\n                return undefined;\n            }\n            else if (key === \"response\") {\n                // Don't log response again\n                return undefined;\n            }\n            else if (key === \"operationSpec\") {\n                // When using sendOperationRequest, the request carries a massive\n                // field with the autorest spec. No need to log it.\n                return undefined;\n            }\n            else if (Array.isArray(value) || isObject(value)) {\n                if (seen.has(value)) {\n                    return \"[Circular]\";\n                }\n                seen.add(value);\n            }\n            return value;\n        }, 2);\n    }\n    sanitizeUrl(value) {\n        if (typeof value !== \"string\" || value === null || value === \"\") {\n            return value;\n        }\n        const url = new URL(value);\n        if (!url.search) {\n            return value;\n        }\n        for (const [key] of url.searchParams) {\n            if (!this.allowedQueryParameters.has(key.toLowerCase())) {\n                url.searchParams.set(key, RedactedString);\n            }\n        }\n        return url.toString();\n    }\n    sanitizeHeaders(obj) {\n        const sanitized = {};\n        for (const key of Object.keys(obj)) {\n            if (this.allowedHeaderNames.has(key.toLowerCase())) {\n                sanitized[key] = obj[key];\n            }\n            else {\n                sanitized[key] = RedactedString;\n            }\n        }\n        return sanitized;\n    }\n    sanitizeQuery(value) {\n        if (typeof value !== \"object\" || value === null) {\n            return value;\n        }\n        const sanitized = {};\n        for (const k of Object.keys(value)) {\n            if (this.allowedQueryParameters.has(k.toLowerCase())) {\n                sanitized[k] = value[k];\n            }\n            else {\n                sanitized[k] = RedactedString;\n            }\n        }\n        return sanitized;\n    }\n}\n//# sourceMappingURL=sanitizer.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { logger as coreLogger } from \"../log.js\";\nimport { Sanitizer } from \"../util/sanitizer.js\";\n/**\n * The programmatic identifier of the logPolicy.\n */\nexport const logPolicyName = \"logPolicy\";\n/**\n * A policy that logs all requests and responses.\n * @param options - Options to configure logPolicy.\n */\nexport function logPolicy(options = {}) {\n    var _a;\n    const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : coreLogger.info;\n    const sanitizer = new Sanitizer({\n        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,\n        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,\n    });\n    return {\n        name: logPolicyName,\n        async sendRequest(request, next) {\n            if (!logger.enabled) {\n                return next(request);\n            }\n            logger(`Request: ${sanitizer.sanitize(request)}`);\n            const response = await next(request);\n            logger(`Response status code: ${response.status}`);\n            logger(`Headers: ${sanitizer.sanitize(response.headers)}`);\n            return response;\n        },\n    };\n}\n//# sourceMappingURL=logPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * The programmatic identifier of the redirectPolicy.\n */\nexport const redirectPolicyName = \"redirectPolicy\";\n/**\n * Methods that are allowed to follow redirects 301 and 302\n */\nconst allowedRedirect = [\"GET\", \"HEAD\"];\n/**\n * A policy to follow Location headers from the server in order\n * to support server-side redirection.\n * In the browser, this policy is not used.\n * @param options - Options to control policy behavior.\n */\nexport function redirectPolicy(options = {}) {\n    const { maxRetries = 20 } = options;\n    return {\n        name: redirectPolicyName,\n        async sendRequest(request, next) {\n            const response = await next(request);\n            return handleRedirect(next, response, maxRetries);\n        },\n    };\n}\nasync function handleRedirect(next, response, maxRetries, currentRetries = 0) {\n    const { request, status, headers } = response;\n    const locationHeader = headers.get(\"location\");\n    if (locationHeader &&\n        (status === 300 ||\n            (status === 301 && allowedRedirect.includes(request.method)) ||\n            (status === 302 && allowedRedirect.includes(request.method)) ||\n            (status === 303 && request.method === \"POST\") ||\n            status === 307) &&\n        currentRetries < maxRetries) {\n        const url = new URL(locationHeader, request.url);\n        request.url = url.toString();\n        // POST request with Status code 303 should be converted into a\n        // redirected GET request if the redirect url is present in the location header\n        if (status === 303) {\n            request.method = \"GET\";\n            request.headers.delete(\"Content-Length\");\n            delete request.body;\n        }\n        request.headers.delete(\"Authorization\");\n        const res = await next(request);\n        return handleRedirect(next, res, maxRetries, currentRetries + 1);\n    }\n    return response;\n}\n//# sourceMappingURL=redirectPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * @internal\n */\nexport function getHeaderName() {\n    return \"x-ms-useragent\";\n}\nfunction getBrowserInfo(userAgent) {\n    const browserRegexes = [\n        { name: \"Firefox\", regex: /Firefox\\/([\\d.]+)/ },\n        { name: \"Safari\", regex: /Version\\/([\\d.]+).*Safari/ },\n    ];\n    for (const browser of browserRegexes) {\n        const match = userAgent.match(browser.regex);\n        if (match) {\n            return { brand: browser.name, version: match[1] };\n        }\n    }\n    return undefined;\n}\nfunction getBrandVersionString(brands) {\n    const brandOrder = [\"Google Chrome\", \"Microsoft Edge\", \"Opera\", \"Brave\", \"Chromium\"];\n    for (const brand of brandOrder) {\n        const foundBrand = brands.find((b) => b.brand === brand);\n        if (foundBrand) {\n            return foundBrand;\n        }\n    }\n    return undefined;\n}\n/**\n * @internal\n */\nexport async function setPlatformSpecificData(map) {\n    const localNavigator = globalThis.navigator;\n    let osPlatform = \"unknown\";\n    if (localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) {\n        const entropyValues = await localNavigator.userAgentData.getHighEntropyValues([\n            \"architecture\",\n            \"platformVersion\",\n        ]);\n        osPlatform = `${entropyValues.architecture}-${entropyValues.platform}-${entropyValues.platformVersion}`;\n        // Get the brand and version\n        const brand = getBrandVersionString(localNavigator.userAgentData.brands);\n        if (brand) {\n            map.set(brand.brand, brand.version);\n        }\n    }\n    else if (localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) {\n        osPlatform = localNavigator.platform;\n        const brand = getBrowserInfo(localNavigator.userAgent);\n        if (brand) {\n            map.set(brand.brand, brand.version);\n        }\n    }\n    else if (typeof globalThis.EdgeRuntime === \"string\") {\n        map.set(\"EdgeRuntime\", globalThis.EdgeRuntime);\n    }\n    map.set(\"OS\", osPlatform);\n}\n//# sourceMappingURL=userAgentPlatform-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport const SDK_VERSION = \"1.19.1\";\nexport const DEFAULT_RETRY_POLICY_COUNT = 3;\n//# sourceMappingURL=constants.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getHeaderName, setPlatformSpecificData } from \"./userAgentPlatform.js\";\nimport { SDK_VERSION } from \"../constants.js\";\nfunction getUserAgentString(telemetryInfo) {\n    const parts = [];\n    for (const [key, value] of telemetryInfo) {\n        const token = value ? `${key}/${value}` : key;\n        parts.push(token);\n    }\n    return parts.join(\" \");\n}\n/**\n * @internal\n */\nexport function getUserAgentHeaderName() {\n    return getHeaderName();\n}\n/**\n * @internal\n */\nexport async function getUserAgentValue(prefix) {\n    const runtimeInfo = new Map();\n    runtimeInfo.set(\"core-rest-pipeline\", SDK_VERSION);\n    await setPlatformSpecificData(runtimeInfo);\n    const defaultAgent = getUserAgentString(runtimeInfo);\n    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;\n    return userAgentValue;\n}\n//# sourceMappingURL=userAgent.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getUserAgentHeaderName, getUserAgentValue } from \"../util/userAgent.js\";\nconst UserAgentHeaderName = getUserAgentHeaderName();\n/**\n * The programmatic identifier of the userAgentPolicy.\n */\nexport const userAgentPolicyName = \"userAgentPolicy\";\n/**\n * A policy that sets the User-Agent header (or equivalent) to reflect\n * the library version.\n * @param options - Options to customize the user agent value.\n */\nexport function userAgentPolicy(options = {}) {\n    const userAgentValue = getUserAgentValue(options.userAgentPrefix);\n    return {\n        name: userAgentPolicyName,\n        async sendRequest(request, next) {\n            if (!request.headers.has(UserAgentHeaderName)) {\n                request.headers.set(UserAgentHeaderName, await userAgentValue);\n            }\n            return next(request);\n        },\n    };\n}\n//# sourceMappingURL=userAgentPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isNodeLike } from \"@azure/core-util\";\nimport { isNodeReadableStream } from \"./typeGuards.js\";\nconst unimplementedMethods = {\n    arrayBuffer: () => {\n        throw new Error(\"Not implemented\");\n    },\n    bytes: () => {\n        throw new Error(\"Not implemented\");\n    },\n    slice: () => {\n        throw new Error(\"Not implemented\");\n    },\n    text: () => {\n        throw new Error(\"Not implemented\");\n    },\n};\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent = Symbol(\"rawContent\");\nfunction hasRawContent(x) {\n    return typeof x[rawContent] === \"function\";\n}\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the blob's content as a Web ReadableStream<Uint8Array>.\n *\n * @internal\n */\nexport function getRawContent(blob) {\n    if (hasRawContent(blob)) {\n        return blob[rawContent]();\n    }\n    else {\n        return blob.stream();\n    }\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(stream, name, options = {}) {\n    var _a, _b, _c, _d;\n    return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a = options.type) !== null && _a !== void 0 ? _a : \"\", lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(), webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : \"\", size: (_d = options.size) !== null && _d !== void 0 ? _d : -1, name, stream: () => {\n            const s = stream();\n            if (isNodeReadableStream(s)) {\n                throw new Error(\"Not supported: a Node stream was provided as input to createFileFromStream.\");\n            }\n            return s;\n        }, [rawContent]: stream });\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(content, name, options = {}) {\n    var _a, _b, _c;\n    if (isNodeLike) {\n        return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a = options.type) !== null && _a !== void 0 ? _a : \"\", lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(), webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : \"\", size: content.byteLength, name, arrayBuffer: async () => content.buffer, stream: () => new Blob([content]).stream(), [rawContent]: () => content });\n    }\n    else {\n        return new File([content], name, options);\n    }\n}\n//# sourceMappingURL=file.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport function isNodeReadableStream(x) {\n    return Boolean(x && typeof x[\"pipe\"] === \"function\");\n}\nexport function isWebReadableStream(x) {\n    return Boolean(x &&\n        typeof x.getReader === \"function\" &&\n        typeof x.tee === \"function\");\n}\nexport function isReadableStream(x) {\n    return isNodeReadableStream(x) || isWebReadableStream(x);\n}\nexport function isBlob(x) {\n    return typeof x.stream === \"function\";\n}\n//# sourceMappingURL=typeGuards.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getRawContent } from \"./file.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./typeGuards.js\";\n/**\n * Drain the content of the given ReadableStream into a Blob.\n * The blob's content may end up in memory or on disk dependent on size.\n */\nfunction drain(stream) {\n    return new Response(stream).blob();\n}\nasync function toBlobPart(source) {\n    if (source instanceof Blob || source instanceof Uint8Array) {\n        return source;\n    }\n    if (isWebReadableStream(source)) {\n        return drain(source);\n    }\n    // If it's not a true Blob, and it's not a Uint8Array, we can assume the source\n    // is a fake File created by createFileFromStream and we can get the original stream\n    // using getRawContent.\n    const rawContent = getRawContent(source);\n    // Shouldn't happen but guard for it anyway\n    if (isNodeReadableStream(rawContent)) {\n        throw new Error(\"Encountered unexpected type. In the browser, `concat` supports Web ReadableStream, Blob, Uint8Array, and files created using `createFile` only.\");\n    }\n    return toBlobPart(rawContent);\n}\n/**\n * Utility function that concatenates a set of binary inputs into one combined output.\n *\n * @param sources - array of sources for the concatenation\n * @returns - in Node, a (() =\\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.\n *           In browser, returns a `Blob` representing all the concatenated inputs.\n *\n * @internal\n */\nexport async function concat(sources) {\n    const parts = [];\n    for (const source of sources) {\n        parts.push(await toBlobPart(typeof source === \"function\" ? source() : source));\n    }\n    return new Blob(parts);\n}\n//# sourceMappingURL=concat.common.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { randomUUID, stringToUint8Array } from \"@azure/core-util\";\nimport { concat } from \"../util/concat.js\";\nimport { isBlob } from \"../util/typeGuards.js\";\nfunction generateBoundary() {\n    return `----AzSDKFormBoundary${randomUUID()}`;\n}\nfunction encodeHeaders(headers) {\n    let result = \"\";\n    for (const [key, value] of headers) {\n        result += `${key}: ${value}\\r\\n`;\n    }\n    return result;\n}\nfunction getLength(source) {\n    if (source instanceof Uint8Array) {\n        return source.byteLength;\n    }\n    else if (isBlob(source)) {\n        // if was created using createFile then -1 means we have an unknown size\n        return source.size === -1 ? undefined : source.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction getTotalLength(sources) {\n    let total = 0;\n    for (const source of sources) {\n        const partLength = getLength(source);\n        if (partLength === undefined) {\n            return undefined;\n        }\n        else {\n            total += partLength;\n        }\n    }\n    return total;\n}\nasync function buildRequestBody(request, parts, boundary) {\n    const sources = [\n        stringToUint8Array(`--${boundary}`, \"utf-8\"),\n        ...parts.flatMap((part) => [\n            stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n            stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"),\n            stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n            part.body,\n            stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\"),\n        ]),\n        stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\"),\n    ];\n    const contentLength = getTotalLength(sources);\n    if (contentLength) {\n        request.headers.set(\"Content-Length\", contentLength);\n    }\n    request.body = await concat(sources);\n}\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = \"multipartPolicy\";\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);\nfunction assertValidBoundary(boundary) {\n    if (boundary.length > maxBoundaryLength) {\n        throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n    }\n    if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {\n        throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n    }\n}\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy() {\n    return {\n        name: multipartPolicyName,\n        async sendRequest(request, next) {\n            var _a;\n            if (!request.multipartBody) {\n                return next(request);\n            }\n            if (request.body) {\n                throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n            }\n            let boundary = request.multipartBody.boundary;\n            const contentTypeHeader = (_a = request.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"multipart/mixed\";\n            const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n            if (!parsedHeader) {\n                throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);\n            }\n            const [, contentType, parsedBoundary] = parsedHeader;\n            if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n                throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);\n            }\n            boundary !== null && boundary !== void 0 ? boundary : (boundary = parsedBoundary);\n            if (boundary) {\n                assertValidBoundary(boundary);\n            }\n            else {\n                boundary = generateBoundary();\n            }\n            request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n            await buildRequestBody(request, request.multipartBody.parts, boundary);\n            request.multipartBody = undefined;\n            return next(request);\n        },\n    };\n}\n//# sourceMappingURL=multipartPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/*\n * NOTE: When moving this file, please update \"browser\" section in package.json\n */\nexport const decompressResponsePolicyName = \"decompressResponsePolicy\";\n/**\n * decompressResponsePolicy is not supported in the browser and attempting\n * to use it will raise an error.\n */\nexport function decompressResponsePolicy() {\n    throw new Error(\"decompressResponsePolicy is not supported in browser environment\");\n}\n//# sourceMappingURL=decompressResponsePolicy-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"@azure/abort-controller\";\nconst StandardAbortMessage = \"The operation was aborted.\";\n/**\n * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n * @param options - The options for delay - currently abort options\n *                  - abortSignal - The abortSignal associated with containing operation.\n *                  - abortErrorMsg - The abort error message associated with containing operation.\n * @returns Resolved promise\n */\nexport function delay(delayInMs, value, options) {\n    return new Promise((resolve, reject) => {\n        let timer = undefined;\n        let onAborted = undefined;\n        const rejectOnAbort = () => {\n            return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));\n        };\n        const removeListeners = () => {\n            if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {\n                options.abortSignal.removeEventListener(\"abort\", onAborted);\n            }\n        };\n        onAborted = () => {\n            if (timer) {\n                clearTimeout(timer);\n            }\n            removeListeners();\n            return rejectOnAbort();\n        };\n        if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {\n            return rejectOnAbort();\n        }\n        timer = setTimeout(() => {\n            removeListeners();\n            resolve(value);\n        }, delayInMs);\n        if (options === null || options === void 0 ? void 0 : options.abortSignal) {\n            options.abortSignal.addEventListener(\"abort\", onAborted);\n        }\n    });\n}\n/**\n * @internal\n * @returns the parsed value or undefined if the parsed value is invalid.\n */\nexport function parseHeaderValueAsNumber(response, headerName) {\n    const value = response.headers.get(headerName);\n    if (!value)\n        return;\n    const valueAsNum = Number(value);\n    if (Number.isNaN(valueAsNum))\n        return;\n    return valueAsNum;\n}\n//# sourceMappingURL=helpers.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { parseHeaderValueAsNumber } from \"../util/helpers.js\";\n/**\n * The header that comes back from Azure services representing\n * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).\n */\nconst RetryAfterHeader = \"Retry-After\";\n/**\n * The headers that come back from Azure services representing\n * the amount of time (minimum) to wait to retry.\n *\n * \"retry-after-ms\", \"x-ms-retry-after-ms\" : milliseconds\n * \"Retry-After\" : seconds or timestamp\n */\nconst AllRetryAfterHeaders = [\"retry-after-ms\", \"x-ms-retry-after-ms\", RetryAfterHeader];\n/**\n * A response is a throttling retry response if it has a throttling status code (429 or 503),\n * as long as one of the [ \"Retry-After\" or \"retry-after-ms\" or \"x-ms-retry-after-ms\" ] headers has a valid value.\n *\n * Returns the `retryAfterInMs` value if the response is a throttling retry response.\n * If not throttling retry response, returns `undefined`.\n *\n * @internal\n */\nfunction getRetryAfterInMs(response) {\n    if (!(response && [429, 503].includes(response.status)))\n        return undefined;\n    try {\n        // Headers: \"retry-after-ms\", \"x-ms-retry-after-ms\", \"Retry-After\"\n        for (const header of AllRetryAfterHeaders) {\n            const retryAfterValue = parseHeaderValueAsNumber(response, header);\n            if (retryAfterValue === 0 || retryAfterValue) {\n                // \"Retry-After\" header ==> seconds\n                // \"retry-after-ms\", \"x-ms-retry-after-ms\" headers ==> milli-seconds\n                const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;\n                return retryAfterValue * multiplyingFactor; // in milli-seconds\n            }\n        }\n        // RetryAfterHeader (\"Retry-After\") has a special case where it might be formatted as a date instead of a number of seconds\n        const retryAfterHeader = response.headers.get(RetryAfterHeader);\n        if (!retryAfterHeader)\n            return;\n        const date = Date.parse(retryAfterHeader);\n        const diff = date - Date.now();\n        // negative diff would mean a date in the past, so retry asap with 0 milliseconds\n        return Number.isFinite(diff) ? Math.max(0, diff) : undefined;\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\n/**\n * A response is a retry response if it has a throttling status code (429 or 503),\n * as long as one of the [ \"Retry-After\" or \"retry-after-ms\" or \"x-ms-retry-after-ms\" ] headers has a valid value.\n */\nexport function isThrottlingRetryResponse(response) {\n    return Number.isFinite(getRetryAfterInMs(response));\n}\nexport function throttlingRetryStrategy() {\n    return {\n        name: \"throttlingRetryStrategy\",\n        retry({ response }) {\n            const retryAfterInMs = getRetryAfterInMs(response);\n            if (!Number.isFinite(retryAfterInMs)) {\n                return { skipStrategy: true };\n            }\n            return {\n                retryAfterInMs,\n            };\n        },\n    };\n}\n//# sourceMappingURL=throttlingRetryStrategy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { calculateRetryDelay } from \"@azure/core-util\";\nimport { isThrottlingRetryResponse } from \"./throttlingRetryStrategy.js\";\n// intervals are in milliseconds\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;\n/**\n * A retry strategy that retries with an exponentially increasing delay in these two cases:\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).\n */\nexport function exponentialRetryStrategy(options = {}) {\n    var _a, _b;\n    const retryInterval = (_a = options.retryDelayInMs) !== null && _a !== void 0 ? _a : DEFAULT_CLIENT_RETRY_INTERVAL;\n    const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    return {\n        name: \"exponentialRetryStrategy\",\n        retry({ retryCount, response, responseError }) {\n            const matchedSystemError = isSystemError(responseError);\n            const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;\n            const isExponential = isExponentialRetryResponse(response);\n            const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;\n            const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);\n            if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {\n                return { skipStrategy: true };\n            }\n            if (responseError && !matchedSystemError && !isExponential) {\n                return { errorToThrow: responseError };\n            }\n            return calculateRetryDelay(retryCount, {\n                retryDelayInMs: retryInterval,\n                maxRetryDelayInMs: maxRetryInterval,\n            });\n        },\n    };\n}\n/**\n * A response is a retry response if it has status codes:\n * - 408, or\n * - Greater or equal than 500, except for 501 and 505.\n */\nexport function isExponentialRetryResponse(response) {\n    return Boolean(response &&\n        response.status !== undefined &&\n        (response.status >= 500 || response.status === 408) &&\n        response.status !== 501 &&\n        response.status !== 505);\n}\n/**\n * Determines whether an error from a pipeline response was triggered in the network layer.\n */\nexport function isSystemError(err) {\n    if (!err) {\n        return false;\n    }\n    return (err.code === \"ETIMEDOUT\" ||\n        err.code === \"ESOCKETTIMEDOUT\" ||\n        err.code === \"ECONNREFUSED\" ||\n        err.code === \"ECONNRESET\" ||\n        err.code === \"ENOENT\" ||\n        err.code === \"ENOTFOUND\");\n}\n//# sourceMappingURL=exponentialRetryStrategy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { delay } from \"../util/helpers.js\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {\n    const logger = options.logger || retryPolicyLogger;\n    return {\n        name: retryPolicyName,\n        async sendRequest(request, next) {\n            var _a, _b;\n            let response;\n            let responseError;\n            let retryCount = -1;\n            retryRequest: while (true) {\n                retryCount += 1;\n                response = undefined;\n                responseError = undefined;\n                try {\n                    logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n                    response = await next(request);\n                    logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n                }\n                catch (e) {\n                    logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n                    // RestErrors are valid targets for the retry strategies.\n                    // If none of the retry strategies can work with them, they will be thrown later in this policy.\n                    // If the received error is not a RestError, it is immediately thrown.\n                    responseError = e;\n                    if (!e || responseError.name !== \"RestError\") {\n                        throw e;\n                    }\n                    response = responseError.response;\n                }\n                if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                    logger.error(`Retry ${retryCount}: Request aborted.`);\n                    const abortError = new AbortError();\n                    throw abortError;\n                }\n                if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n                    logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n                    if (responseError) {\n                        throw responseError;\n                    }\n                    else if (response) {\n                        return response;\n                    }\n                    else {\n                        throw new Error(\"Maximum retries reached with no response or error to throw\");\n                    }\n                }\n                logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n                strategiesLoop: for (const strategy of strategies) {\n                    const strategyLogger = strategy.logger || retryPolicyLogger;\n                    strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n                    const modifiers = strategy.retry({\n                        retryCount,\n                        response,\n                        responseError,\n                    });\n                    if (modifiers.skipStrategy) {\n                        strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n                        continue strategiesLoop;\n                    }\n                    const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n                    if (errorToThrow) {\n                        strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n                        throw errorToThrow;\n                    }\n                    if (retryAfterInMs || retryAfterInMs === 0) {\n                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n                        await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n                        continue retryRequest;\n                    }\n                    if (redirectTo) {\n                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n                        request.url = redirectTo;\n                        continue retryRequest;\n                    }\n                }\n                if (responseError) {\n                    logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n                    throw responseError;\n                }\n                if (response) {\n                    logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n                    return response;\n                }\n                // If all the retries skip and there's no response,\n                // we're still in the retry loop, so a new request will be sent\n                // until `maxRetries` is reached.\n            }\n        },\n    };\n}\n//# sourceMappingURL=retryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy.js\";\nimport { throttlingRetryStrategy } from \"../retryStrategies/throttlingRetryStrategy.js\";\nimport { retryPolicy } from \"./retryPolicy.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n/**\n * Name of the {@link defaultRetryPolicy}\n */\nexport const defaultRetryPolicyName = \"defaultRetryPolicy\";\n/**\n * A policy that retries according to three strategies:\n * - When the server sends a 429 response with a Retry-After header.\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.\n */\nexport function defaultRetryPolicy(options = {}) {\n    var _a;\n    return {\n        name: defaultRetryPolicyName,\n        sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {\n            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,\n        }).sendRequest,\n    };\n}\n//# sourceMappingURL=defaultRetryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction normalizeName(name) {\n    return name.toLowerCase();\n}\nfunction* headerIterator(map) {\n    for (const entry of map.values()) {\n        yield [entry.name, entry.value];\n    }\n}\nclass HttpHeadersImpl {\n    constructor(rawHeaders) {\n        this._headersMap = new Map();\n        if (rawHeaders) {\n            for (const headerName of Object.keys(rawHeaders)) {\n                this.set(headerName, rawHeaders[headerName]);\n            }\n        }\n    }\n    /**\n     * Set a header in this collection with the provided name and value. The name is\n     * case-insensitive.\n     * @param name - The name of the header to set. This value is case-insensitive.\n     * @param value - The value of the header to set.\n     */\n    set(name, value) {\n        this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });\n    }\n    /**\n     * Get the header value for the provided header name, or undefined if no header exists in this\n     * collection with the provided name.\n     * @param name - The name of the header. This value is case-insensitive.\n     */\n    get(name) {\n        var _a;\n        return (_a = this._headersMap.get(normalizeName(name))) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    /**\n     * Get whether or not this header collection contains a header entry for the provided header name.\n     * @param name - The name of the header to set. This value is case-insensitive.\n     */\n    has(name) {\n        return this._headersMap.has(normalizeName(name));\n    }\n    /**\n     * Remove the header with the provided headerName.\n     * @param name - The name of the header to remove.\n     */\n    delete(name) {\n        this._headersMap.delete(normalizeName(name));\n    }\n    /**\n     * Get the JSON object representation of this HTTP header collection.\n     */\n    toJSON(options = {}) {\n        const result = {};\n        if (options.preserveCase) {\n            for (const entry of this._headersMap.values()) {\n                result[entry.name] = entry.value;\n            }\n        }\n        else {\n            for (const [normalizedName, entry] of this._headersMap) {\n                result[normalizedName] = entry.value;\n            }\n        }\n        return result;\n    }\n    /**\n     * Get the string representation of this HTTP header collection.\n     */\n    toString() {\n        return JSON.stringify(this.toJSON({ preserveCase: true }));\n    }\n    /**\n     * Iterate over tuples of header [name, value] pairs.\n     */\n    [Symbol.iterator]() {\n        return headerIterator(this._headersMap);\n    }\n}\n/**\n * Creates an object that satisfies the `HttpHeaders` interface.\n * @param rawHeaders - A simple object representing initial headers\n */\nexport function createHttpHeaders(rawHeaders) {\n    return new HttpHeadersImpl(rawHeaders);\n}\n//# sourceMappingURL=httpHeaders.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isNodeLike, stringToUint8Array } from \"@azure/core-util\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\nfunction formDataToFormDataMap(formData) {\n    var _a;\n    const formDataMap = {};\n    for (const [key, value] of formData.entries()) {\n        (_a = formDataMap[key]) !== null && _a !== void 0 ? _a : (formDataMap[key] = []);\n        formDataMap[key].push(value);\n    }\n    return formDataMap;\n}\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy() {\n    return {\n        name: formDataPolicyName,\n        async sendRequest(request, next) {\n            if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n                request.formData = formDataToFormDataMap(request.body);\n                request.body = undefined;\n            }\n            if (request.formData) {\n                const contentType = request.headers.get(\"Content-Type\");\n                if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n                    request.body = wwwFormUrlEncode(request.formData);\n                }\n                else {\n                    await prepareFormData(request.formData, request);\n                }\n                request.formData = undefined;\n            }\n            return next(request);\n        },\n    };\n}\nfunction wwwFormUrlEncode(formData) {\n    const urlSearchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(formData)) {\n        if (Array.isArray(value)) {\n            for (const subValue of value) {\n                urlSearchParams.append(key, subValue.toString());\n            }\n        }\n        else {\n            urlSearchParams.append(key, value.toString());\n        }\n    }\n    return urlSearchParams.toString();\n}\nasync function prepareFormData(formData, request) {\n    // validate content type (multipart/form-data)\n    const contentType = request.headers.get(\"Content-Type\");\n    if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n        // content type is specified and is not multipart/form-data. Exit.\n        return;\n    }\n    request.headers.set(\"Content-Type\", contentType !== null && contentType !== void 0 ? contentType : \"multipart/form-data\");\n    // set body to MultipartRequestBody using content from FormDataMap\n    const parts = [];\n    for (const [fieldName, values] of Object.entries(formData)) {\n        for (const value of Array.isArray(values) ? values : [values]) {\n            if (typeof value === \"string\") {\n                parts.push({\n                    headers: createHttpHeaders({\n                        \"Content-Disposition\": `form-data; name=\"${fieldName}\"`,\n                    }),\n                    body: stringToUint8Array(value, \"utf-8\"),\n                });\n            }\n            else if (value === undefined || value === null || typeof value !== \"object\") {\n                throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);\n            }\n            else {\n                // using || instead of ?? here since if value.name is empty we should create a file name\n                const fileName = value.name || \"blob\";\n                const headers = createHttpHeaders();\n                headers.set(\"Content-Disposition\", `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`);\n                // again, || is used since an empty value.type means the content type is unset\n                headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n                parts.push({\n                    headers,\n                    body: value,\n                });\n            }\n        }\n    }\n    request.multipartBody = { parts };\n}\n//# sourceMappingURL=formDataPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport const proxyPolicyName = \"proxyPolicy\";\nconst errorMessage = \"proxyPolicy is not supported in browser environment\";\nexport function getDefaultProxySettings() {\n    throw new Error(errorMessage);\n}\n/**\n * proxyPolicy is not supported in the browser and attempting\n * to use it will raise an error.\n */\nexport function proxyPolicy() {\n    throw new Error(errorMessage);\n}\n/**\n * A function to reset the cached agents.\n * proxyPolicy is not supported in the browser and attempting\n * to use it will raise an error.\n * @internal\n */\nexport function resetCachedProxyAgents() {\n    throw new Error(errorMessage);\n}\n//# sourceMappingURL=proxyPolicy.common.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * The programmatic identifier of the setClientRequestIdPolicy.\n */\nexport const setClientRequestIdPolicyName = \"setClientRequestIdPolicy\";\n/**\n * Each PipelineRequest gets a unique id upon creation.\n * This policy passes that unique id along via an HTTP header to enable better\n * telemetry and tracing.\n * @param requestIdHeaderName - The name of the header to pass the request ID to.\n */\nexport function setClientRequestIdPolicy(requestIdHeaderName = \"x-ms-client-request-id\") {\n    return {\n        name: setClientRequestIdPolicyName,\n        async sendRequest(request, next) {\n            if (!request.headers.has(requestIdHeaderName)) {\n                request.headers.set(requestIdHeaderName, request.requestId);\n            }\n            return next(request);\n        },\n    };\n}\n//# sourceMappingURL=setClientRequestIdPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Name of the Agent Policy\n */\nexport const agentPolicyName = \"agentPolicy\";\n/**\n * Gets a pipeline policy that sets http.agent\n */\nexport function agentPolicy(agent) {\n    return {\n        name: agentPolicyName,\n        sendRequest: async (req, next) => {\n            // Users may define an agent on the request, honor it over the client level one\n            if (!req.agent) {\n                req.agent = agent;\n            }\n            return next(req);\n        },\n    };\n}\n//# sourceMappingURL=agentPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Name of the TLS Policy\n */\nexport const tlsPolicyName = \"tlsPolicy\";\n/**\n * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.\n */\nexport function tlsPolicy(tlsSettings) {\n    return {\n        name: tlsPolicyName,\n        sendRequest: async (req, next) => {\n            // Users may define a request tlsSettings, honor those over the client level one\n            if (!req.tlsSettings) {\n                req.tlsSettings = tlsSettings;\n            }\n            return next(req);\n        },\n    };\n}\n//# sourceMappingURL=tlsPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport const custom = {};\n//# sourceMappingURL=inspect.common.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isError } from \"@azure/core-util\";\nimport { custom } from \"./util/inspect.js\";\nimport { Sanitizer } from \"./util/sanitizer.js\";\nconst errorSanitizer = new Sanitizer();\n/**\n * A custom error type for failed pipeline requests.\n */\nexport class RestError extends Error {\n    constructor(message, options = {}) {\n        super(message);\n        this.name = \"RestError\";\n        this.code = options.code;\n        this.statusCode = options.statusCode;\n        // The request and response may contain sensitive information in the headers or body.\n        // To help prevent this sensitive information being accidentally logged, the request and response\n        // properties are marked as non-enumerable here. This prevents them showing up in the output of\n        // JSON.stringify and console.log.\n        Object.defineProperty(this, \"request\", { value: options.request, enumerable: false });\n        Object.defineProperty(this, \"response\", { value: options.response, enumerable: false });\n        Object.setPrototypeOf(this, RestError.prototype);\n    }\n    /**\n     * Logging method for util.inspect in Node\n     */\n    [custom]() {\n        // Extract non-enumerable properties and add them back. This is OK since in this output the request and\n        // response get sanitized.\n        return `RestError: ${this.message} \\n ${errorSanitizer.sanitize(Object.assign(Object.assign({}, this), { request: this.request, response: this.response }))}`;\n    }\n}\n/**\n * Something went wrong when making the request.\n * This means the actual request failed for some reason,\n * such as a DNS issue or the connection being lost.\n */\nRestError.REQUEST_SEND_ERROR = \"REQUEST_SEND_ERROR\";\n/**\n * This means that parsing the response from the server failed.\n * It may have been malformed.\n */\nRestError.PARSE_ERROR = \"PARSE_ERROR\";\n/**\n * Typeguard for RestError\n * @param e - Something caught by a catch clause.\n */\nexport function isRestError(e) {\n    if (e instanceof RestError) {\n        return true;\n    }\n    return isError(e) && e.name === \"RestError\";\n}\n//# sourceMappingURL=restError.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTracingClient, } from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport { getUserAgentValue } from \"../util/userAgent.js\";\nimport { logger } from \"../log.js\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError.js\";\nimport { Sanitizer } from \"../util/sanitizer.js\";\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options = {}) {\n    const userAgentPromise = getUserAgentValue(options.userAgentPrefix);\n    const sanitizer = new Sanitizer({\n        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,\n    });\n    const tracingClient = tryCreateTracingClient();\n    return {\n        name: tracingPolicyName,\n        async sendRequest(request, next) {\n            var _a;\n            if (!tracingClient) {\n                return next(request);\n            }\n            const userAgent = await userAgentPromise;\n            const spanAttributes = {\n                \"http.url\": sanitizer.sanitizeUrl(request.url),\n                \"http.method\": request.method,\n                \"http.user_agent\": userAgent,\n                requestId: request.requestId,\n            };\n            if (userAgent) {\n                spanAttributes[\"http.user_agent\"] = userAgent;\n            }\n            const { span, tracingContext } = (_a = tryCreateSpan(tracingClient, request, spanAttributes)) !== null && _a !== void 0 ? _a : {};\n            if (!span || !tracingContext) {\n                return next(request);\n            }\n            try {\n                const response = await tracingClient.withContext(tracingContext, next, request);\n                tryProcessResponse(span, response);\n                return response;\n            }\n            catch (err) {\n                tryProcessError(span, err);\n                throw err;\n            }\n        },\n    };\n}\nfunction tryCreateTracingClient() {\n    try {\n        return createTracingClient({\n            namespace: \"\",\n            packageName: \"@azure/core-rest-pipeline\",\n            packageVersion: SDK_VERSION,\n        });\n    }\n    catch (e) {\n        logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n        return undefined;\n    }\n}\nfunction tryCreateSpan(tracingClient, request, spanAttributes) {\n    try {\n        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n        const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {\n            spanKind: \"client\",\n            spanAttributes,\n        });\n        // If the span is not recording, don't do any more work.\n        if (!span.isRecording()) {\n            span.end();\n            return undefined;\n        }\n        // set headers\n        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);\n        for (const [key, value] of Object.entries(headers)) {\n            request.headers.set(key, value);\n        }\n        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n    }\n    catch (e) {\n        logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n        return undefined;\n    }\n}\nfunction tryProcessError(span, error) {\n    try {\n        span.setStatus({\n            status: \"error\",\n            error: isError(error) ? error : undefined,\n        });\n        if (isRestError(error) && error.statusCode) {\n            span.setAttribute(\"http.status_code\", error.statusCode);\n        }\n        span.end();\n    }\n    catch (e) {\n        logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n    }\n}\nfunction tryProcessResponse(span, response) {\n    try {\n        span.setAttribute(\"http.status_code\", response.status);\n        const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n        if (serviceRequestId) {\n            span.setAttribute(\"serviceRequestId\", serviceRequestId);\n        }\n        // Per semantic conventions, only set the status to error if the status code is 4xx or 5xx.\n        // Otherwise, the status MUST remain unset.\n        // https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status\n        if (response.status >= 400) {\n            span.setStatus({\n                status: \"error\",\n            });\n        }\n        span.end();\n    }\n    catch (e) {\n        logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n    }\n}\n//# sourceMappingURL=tracingPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { logPolicy } from \"./policies/logPolicy.js\";\nimport { createEmptyPipeline } from \"./pipeline.js\";\nimport { redirectPolicy } from \"./policies/redirectPolicy.js\";\nimport { userAgentPolicy } from \"./policies/userAgentPolicy.js\";\nimport { multipartPolicy, multipartPolicyName } from \"./policies/multipartPolicy.js\";\nimport { decompressResponsePolicy } from \"./policies/decompressResponsePolicy.js\";\nimport { defaultRetryPolicy } from \"./policies/defaultRetryPolicy.js\";\nimport { formDataPolicy } from \"./policies/formDataPolicy.js\";\nimport { isNodeLike } from \"@azure/core-util\";\nimport { proxyPolicy } from \"./policies/proxyPolicy.js\";\nimport { setClientRequestIdPolicy } from \"./policies/setClientRequestIdPolicy.js\";\nimport { agentPolicy } from \"./policies/agentPolicy.js\";\nimport { tlsPolicy } from \"./policies/tlsPolicy.js\";\nimport { tracingPolicy } from \"./policies/tracingPolicy.js\";\n/**\n * Create a new pipeline with a default set of customizable policies.\n * @param options - Options to configure a custom pipeline.\n */\nexport function createPipelineFromOptions(options) {\n    var _a;\n    const pipeline = createEmptyPipeline();\n    if (isNodeLike) {\n        if (options.agent) {\n            pipeline.addPolicy(agentPolicy(options.agent));\n        }\n        if (options.tlsOptions) {\n            pipeline.addPolicy(tlsPolicy(options.tlsOptions));\n        }\n        pipeline.addPolicy(proxyPolicy(options.proxyOptions));\n        pipeline.addPolicy(decompressResponsePolicy());\n    }\n    pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });\n    pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));\n    pipeline.addPolicy(setClientRequestIdPolicy((_a = options.telemetryOptions) === null || _a === void 0 ? void 0 : _a.clientRequestIdHeaderName));\n    // The multipart policy is added after policies with no phase, so that\n    // policies can be added between it and formDataPolicy to modify\n    // properties (e.g., making the boundary constant in recorded tests).\n    pipeline.addPolicy(multipartPolicy(), { afterPhase: \"Deserialize\" });\n    pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n    pipeline.addPolicy(tracingPolicy(Object.assign(Object.assign({}, options.userAgentOptions), options.loggingOptions)), {\n        afterPhase: \"Retry\",\n    });\n    if (isNodeLike) {\n        // Both XHR and Fetch expect to handle redirects automatically,\n        // so only include this policy when we're in Node.\n        pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: \"Retry\" });\n    }\n    pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: \"Sign\" });\n    return pipeline;\n}\n//# sourceMappingURL=createPipelineFromOptions.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards.js\";\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n    // File objects count as a type of Blob, so we want to use instanceof explicitly\n    return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n    /**\n     * Makes a request over an underlying transport layer and returns the response.\n     * @param request - The request to be made.\n     */\n    async sendRequest(request) {\n        const url = new URL(request.url);\n        const isInsecure = url.protocol !== \"https:\";\n        if (isInsecure && !request.allowInsecureConnection) {\n            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n        }\n        if (request.proxySettings) {\n            throw new Error(\"HTTP proxy is not supported in browser environment\");\n        }\n        try {\n            return await makeRequest(request);\n        }\n        catch (e) {\n            throw getError(e, request);\n        }\n    }\n}\n/**\n * Sends a request\n */\nasync function makeRequest(request) {\n    const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n    try {\n        const headers = buildFetchHeaders(request.headers);\n        const { streaming, body: requestBody } = buildRequestBody(request);\n        const requestInit = Object.assign(Object.assign({ body: requestBody, method: request.method, headers: headers, signal: abortController.signal }, (\"credentials\" in Request.prototype\n            ? { credentials: request.withCredentials ? \"include\" : \"same-origin\" }\n            : {})), (\"cache\" in Request.prototype ? { cache: \"no-store\" } : {}));\n        // According to https://fetch.spec.whatwg.org/#fetch-method,\n        // init.duplex must be set when body is a ReadableStream object.\n        // currently \"half\" is the only valid value.\n        if (streaming) {\n            requestInit.duplex = \"half\";\n        }\n        /**\n         * Developers of the future:\n         * Do not set redirect: \"manual\" as part\n         * of request options.\n         * It will not work as you expect.\n         */\n        const response = await fetch(request.url, requestInit);\n        // If we're uploading a blob, we need to fire the progress event manually\n        if (isBlob(request.body) && request.onUploadProgress) {\n            request.onUploadProgress({ loadedBytes: request.body.size });\n        }\n        return buildPipelineResponse(response, request, abortControllerCleanup);\n    }\n    catch (e) {\n        abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n        throw e;\n    }\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse, request, abortControllerCleanup) {\n    var _a, _b;\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n        request,\n        headers,\n        status: httpResponse.status,\n    };\n    const bodyStream = isWebReadableStream(httpResponse.body)\n        ? buildBodyStream(httpResponse.body, {\n            onProgress: request.onDownloadProgress,\n            onEnd: abortControllerCleanup,\n        })\n        : httpResponse.body;\n    if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) ||\n        ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n        if (request.enableBrowserStreams) {\n            response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n        }\n        else {\n            const responseStream = new Response(bodyStream);\n            response.blobBody = responseStream.blob();\n            abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n        }\n    }\n    else {\n        const responseStream = new Response(bodyStream);\n        response.bodyAsText = await responseStream.text();\n        abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n    }\n    return response;\n}\nfunction setupAbortSignal(request) {\n    const abortController = new AbortController();\n    // Cleanup function\n    let abortControllerCleanup;\n    /**\n     * Attach an abort listener to the request\n     */\n    let abortListener;\n    if (request.abortSignal) {\n        if (request.abortSignal.aborted) {\n            throw new AbortError(\"The operation was aborted. Request has already been canceled.\");\n        }\n        abortListener = (event) => {\n            if (event.type === \"abort\") {\n                abortController.abort();\n            }\n        };\n        request.abortSignal.addEventListener(\"abort\", abortListener);\n        abortControllerCleanup = () => {\n            var _a;\n            if (abortListener) {\n                (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n            }\n        };\n    }\n    // If a timeout was passed, call the abort signal once the time elapses\n    if (request.timeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n        }, request.timeout);\n    }\n    return { abortController, abortControllerCleanup };\n}\n/**\n * Gets the specific error\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\nfunction getError(e, request) {\n    var _a;\n    if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n        return e;\n    }\n    else {\n        return new RestError(`Error sending request: ${e.message}`, {\n            code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n            request,\n        });\n    }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n    const headers = new Headers();\n    for (const [name, value] of pipelineHeaders) {\n        headers.append(name, value);\n    }\n    return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n    const responseHeaders = createHttpHeaders();\n    for (const [name, value] of httpResponse.headers) {\n        responseHeaders.set(name, value);\n    }\n    return responseHeaders;\n}\nfunction buildRequestBody(request) {\n    const body = typeof request.body === \"function\" ? request.body() : request.body;\n    if (isNodeReadableStream(body)) {\n        throw new Error(\"Node streams are not supported in browser environment.\");\n    }\n    return isWebReadableStream(body)\n        ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) }\n        : { streaming: false, body };\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, options = {}) {\n    let loadedBytes = 0;\n    const { onProgress, onEnd } = options;\n    // If the current browser supports pipeThrough we use a TransformStream\n    // to report progress\n    if (isTransformStreamSupported(readableStream)) {\n        return readableStream.pipeThrough(new TransformStream({\n            transform(chunk, controller) {\n                if (chunk === null) {\n                    controller.terminate();\n                    return;\n                }\n                controller.enqueue(chunk);\n                loadedBytes += chunk.length;\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n            flush() {\n                onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n            },\n        }));\n    }\n    else {\n        // If we can't use transform streams, wrap the original stream in a new readable stream\n        // and use pull to enqueue each chunk and report progress.\n        const reader = readableStream.getReader();\n        return new ReadableStream({\n            async pull(controller) {\n                var _a;\n                const { done, value } = await reader.read();\n                // When no more data needs to be consumed, break the reading\n                if (done || !value) {\n                    onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n                    // Close the stream\n                    controller.close();\n                    reader.releaseLock();\n                    return;\n                }\n                loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n                // Enqueue the next data chunk into our target stream\n                controller.enqueue(value);\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n            cancel(reason) {\n                onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n                return reader.cancel(reason);\n            },\n        });\n    }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n    return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n    return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n//# sourceMappingURL=fetchHttpClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createFetchHttpClient } from \"./fetchHttpClient.js\";\n/**\n * Create the correct HttpClient for the current environment.\n */\nexport function createDefaultHttpClient() {\n    return createFetchHttpClient();\n}\n//# sourceMappingURL=defaultHttpClient-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { randomUUID } from \"@azure/core-util\";\nclass PipelineRequestImpl {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.url = options.url;\n        this.body = options.body;\n        this.headers = (_a = options.headers) !== null && _a !== void 0 ? _a : createHttpHeaders();\n        this.method = (_b = options.method) !== null && _b !== void 0 ? _b : \"GET\";\n        this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;\n        this.multipartBody = options.multipartBody;\n        this.formData = options.formData;\n        this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;\n        this.proxySettings = options.proxySettings;\n        this.streamResponseStatusCodes = options.streamResponseStatusCodes;\n        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;\n        this.abortSignal = options.abortSignal;\n        this.tracingOptions = options.tracingOptions;\n        this.onUploadProgress = options.onUploadProgress;\n        this.onDownloadProgress = options.onDownloadProgress;\n        this.requestId = options.requestId || randomUUID();\n        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;\n        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;\n        this.agent = options.agent;\n        this.tlsSettings = options.tlsSettings;\n    }\n}\n/**\n * Creates a new pipeline request with the given options.\n * This method is to allow for the easy setting of default values and not required.\n * @param options - The options to create the request with.\n */\nexport function createPipelineRequest(options) {\n    return new PipelineRequestImpl(options);\n}\n//# sourceMappingURL=pipelineRequest.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy.js\";\nimport { retryPolicy } from \"./retryPolicy.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n/**\n * The programmatic identifier of the exponentialRetryPolicy.\n */\nexport const exponentialRetryPolicyName = \"exponentialRetryPolicy\";\n/**\n * A policy that attempts to retry requests while introducing an exponentially increasing delay.\n * @param options - Options that configure retry logic.\n */\nexport function exponentialRetryPolicy(options = {}) {\n    var _a;\n    return retryPolicy([\n        exponentialRetryStrategy(Object.assign(Object.assign({}, options), { ignoreSystemErrors: true })),\n    ], {\n        maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,\n    });\n}\n//# sourceMappingURL=exponentialRetryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy.js\";\nimport { retryPolicy } from \"./retryPolicy.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n/**\n * Name of the {@link systemErrorRetryPolicy}\n */\nexport const systemErrorRetryPolicyName = \"systemErrorRetryPolicy\";\n/**\n * A retry policy that specifically seeks to handle errors in the\n * underlying transport layer (e.g. DNS lookup failures) rather than\n * retryable error codes from the server itself.\n * @param options - Options that customize the policy.\n */\nexport function systemErrorRetryPolicy(options = {}) {\n    var _a;\n    return {\n        name: systemErrorRetryPolicyName,\n        sendRequest: retryPolicy([\n            exponentialRetryStrategy(Object.assign(Object.assign({}, options), { ignoreHttpStatusCodes: true })),\n        ], {\n            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,\n        }).sendRequest,\n    };\n}\n//# sourceMappingURL=systemErrorRetryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { throttlingRetryStrategy } from \"../retryStrategies/throttlingRetryStrategy.js\";\nimport { retryPolicy } from \"./retryPolicy.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n/**\n * Name of the {@link throttlingRetryPolicy}\n */\nexport const throttlingRetryPolicyName = \"throttlingRetryPolicy\";\n/**\n * A policy that retries when the server sends a 429 response with a Retry-After header.\n *\n * To learn more, please refer to\n * https://learn.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://learn.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://learn.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n *\n * @param options - Options that configure retry logic.\n */\nexport function throttlingRetryPolicy(options = {}) {\n    var _a;\n    return {\n        name: throttlingRetryPolicyName,\n        sendRequest: retryPolicy([throttlingRetryStrategy()], {\n            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,\n        }).sendRequest,\n    };\n}\n//# sourceMappingURL=throttlingRetryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { delay } from \"./helpers.js\";\n// Default options for the cycler if none are provided\nexport const DEFAULT_CYCLER_OPTIONS = {\n    forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires\n    retryIntervalInMs: 3000, // Allow refresh attempts every 3s\n    refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry\n};\n/**\n * Converts an an unreliable access token getter (which may resolve with null)\n * into an AccessTokenGetter by retrying the unreliable getter in a regular\n * interval.\n *\n * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.\n * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.\n * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.\n * @returns - A promise that, if it resolves, will resolve with an access token.\n */\nasync function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {\n    // This wrapper handles exceptions gracefully as long as we haven't exceeded\n    // the timeout.\n    async function tryGetAccessToken() {\n        if (Date.now() < refreshTimeout) {\n            try {\n                return await getAccessToken();\n            }\n            catch (_a) {\n                return null;\n            }\n        }\n        else {\n            const finalToken = await getAccessToken();\n            // Timeout is up, so throw if it's still null\n            if (finalToken === null) {\n                throw new Error(\"Failed to refresh access token.\");\n            }\n            return finalToken;\n        }\n    }\n    let token = await tryGetAccessToken();\n    while (token === null) {\n        await delay(retryIntervalInMs);\n        token = await tryGetAccessToken();\n    }\n    return token;\n}\n/**\n * Creates a token cycler from a credential, scopes, and optional settings.\n *\n * A token cycler represents a way to reliably retrieve a valid access token\n * from a TokenCredential. It will handle initializing the token, refreshing it\n * when it nears expiration, and synchronizes refresh attempts to avoid\n * concurrency hazards.\n *\n * @param credential - the underlying TokenCredential that provides the access\n * token\n * @param tokenCyclerOptions - optionally override default settings for the cycler\n *\n * @returns - a function that reliably produces a valid access token\n */\nexport function createTokenCycler(credential, tokenCyclerOptions) {\n    let refreshWorker = null;\n    let token = null;\n    let tenantId;\n    const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);\n    /**\n     * This little holder defines several predicates that we use to construct\n     * the rules of refreshing the token.\n     */\n    const cycler = {\n        /**\n         * Produces true if a refresh job is currently in progress.\n         */\n        get isRefreshing() {\n            return refreshWorker !== null;\n        },\n        /**\n         * Produces true if the cycler SHOULD refresh (we are within the refresh\n         * window and not already refreshing)\n         */\n        get shouldRefresh() {\n            var _a;\n            if (cycler.isRefreshing) {\n                return false;\n            }\n            if ((token === null || token === void 0 ? void 0 : token.refreshAfterTimestamp) && token.refreshAfterTimestamp < Date.now()) {\n                return true;\n            }\n            return ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now();\n        },\n        /**\n         * Produces true if the cycler MUST refresh (null or nearly-expired\n         * token).\n         */\n        get mustRefresh() {\n            return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());\n        },\n    };\n    /**\n     * Starts a refresh job or returns the existing job if one is already\n     * running.\n     */\n    function refresh(scopes, getTokenOptions) {\n        var _a;\n        if (!cycler.isRefreshing) {\n            // We bind `scopes` here to avoid passing it around a lot\n            const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);\n            // Take advantage of promise chaining to insert an assignment to `token`\n            // before the refresh can be considered done.\n            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, \n            // If we don't have a token, then we should timeout immediately\n            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now())\n                .then((_token) => {\n                refreshWorker = null;\n                token = _token;\n                tenantId = getTokenOptions.tenantId;\n                return token;\n            })\n                .catch((reason) => {\n                // We also should reset the refresher if we enter a failed state.  All\n                // existing awaiters will throw, but subsequent requests will start a\n                // new retry chain.\n                refreshWorker = null;\n                token = null;\n                tenantId = undefined;\n                throw reason;\n            });\n        }\n        return refreshWorker;\n    }\n    return async (scopes, tokenOptions) => {\n        //\n        // Simple rules:\n        // - If we MUST refresh, then return the refresh task, blocking\n        //   the pipeline until a token is available.\n        // - If we SHOULD refresh, then run refresh but don't return it\n        //   (we can still use the cached token).\n        // - Return the token, since it's fine if we didn't return in\n        //   step 1.\n        //\n        const hasClaimChallenge = Boolean(tokenOptions.claims);\n        const tenantIdChanged = tenantId !== tokenOptions.tenantId;\n        if (hasClaimChallenge) {\n            // If we've received a claim, we know the existing token isn't valid\n            // We want to clear it so that that refresh worker won't use the old expiration time as a timeout\n            token = null;\n        }\n        // If the tenantId passed in token options is different to the one we have\n        // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to\n        // refresh the token with the new tenantId or token.\n        const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;\n        if (mustRefresh) {\n            return refresh(scopes, tokenOptions);\n        }\n        if (cycler.shouldRefresh) {\n            refresh(scopes, tokenOptions);\n        }\n        return token;\n    };\n}\n//# sourceMappingURL=tokenCycler.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport { isRestError } from \"../restError.js\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Try to send the given request.\n *\n * When a response is received, returns a tuple of the response received and, if the response was received\n * inside a thrown RestError, the RestError that was thrown.\n *\n * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it\n * will be rethrown.\n */\nasync function trySendRequest(request, next) {\n    try {\n        return [await next(request), undefined];\n    }\n    catch (e) {\n        if (isRestError(e) && e.response) {\n            return [e.response, e];\n        }\n        else {\n            throw e;\n        }\n    }\n}\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options) {\n    const { scopes, getAccessToken, request } = options;\n    // Enable CAE true by default\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n        enableCae: true,\n    };\n    const accessToken = await getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n        options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction isChallengeResponse(response) {\n    return response.status === 401 && response.headers.has(\"WWW-Authenticate\");\n}\n/**\n * Re-authorize the request for CAE challenge.\n * The response containing the challenge is `options.response`.\n * If this method returns true, the underlying request will be sent once again.\n */\nasync function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {\n    var _a;\n    const { scopes } = onChallengeOptions;\n    const accessToken = await onChallengeOptions.getAccessToken(scopes, {\n        enableCae: true,\n        claims: caeClaims,\n    });\n    if (!accessToken) {\n        return false;\n    }\n    onChallengeOptions.request.headers.set(\"Authorization\", `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n    return true;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n    var _a, _b, _c;\n    const { credential, scopes, challengeCallbacks } = options;\n    const logger = options.logger || coreLogger;\n    const callbacks = {\n        authorizeRequest: (_b = (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) === null || _a === void 0 ? void 0 : _a.bind(challengeCallbacks)) !== null && _b !== void 0 ? _b : defaultAuthorizeRequest,\n        authorizeRequestOnChallenge: (_c = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge) === null || _c === void 0 ? void 0 : _c.bind(challengeCallbacks),\n    };\n    // This function encapsulates the entire process of reliably retrieving the token\n    // The options are left out of the public API until there's demand to configure this.\n    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n    // in order to pass through the `options` object.\n    const getAccessToken = credential\n        ? createTokenCycler(credential /* , options */)\n        : () => Promise.resolve(null);\n    return {\n        name: bearerTokenAuthenticationPolicyName,\n        /**\n         * If there's no challenge parameter:\n         * - It will try to retrieve the token using the cache, or the credential's getToken.\n         * - Then it will try the next policy with or without the retrieved token.\n         *\n         * It uses the challenge parameters to:\n         * - Skip a first attempt to get the token from the credential if there's no cached token,\n         *   since it expects the token to be retrievable only after the challenge.\n         * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n         * - Send an initial request to receive the challenge if it fails.\n         * - Process a challenge if the response contains it.\n         * - Retrieve a token with the challenge information, then re-send the request.\n         */\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            await callbacks.authorizeRequest({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                request,\n                getAccessToken,\n                logger,\n            });\n            let response;\n            let error;\n            let shouldSendRequest;\n            [response, error] = await trySendRequest(request, next);\n            if (isChallengeResponse(response)) {\n                let claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n                // Handle CAE by default when receive CAE claim\n                if (claims) {\n                    let parsedClaim;\n                    // Return the response immediately if claims is not a valid base64 encoded string\n                    try {\n                        parsedClaim = atob(claims);\n                    }\n                    catch (e) {\n                        logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                        return response;\n                    }\n                    shouldSendRequest = await authorizeRequestOnCaeChallenge({\n                        scopes: Array.isArray(scopes) ? scopes : [scopes],\n                        response,\n                        request,\n                        getAccessToken,\n                        logger,\n                    }, parsedClaim);\n                    // Send updated request and handle response for RestError\n                    if (shouldSendRequest) {\n                        [response, error] = await trySendRequest(request, next);\n                    }\n                }\n                else if (callbacks.authorizeRequestOnChallenge) {\n                    // Handle custom challenges when client provides custom callback\n                    shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n                        scopes: Array.isArray(scopes) ? scopes : [scopes],\n                        request,\n                        response,\n                        getAccessToken,\n                        logger,\n                    });\n                    // Send updated request and handle response for RestError\n                    if (shouldSendRequest) {\n                        [response, error] = await trySendRequest(request, next);\n                    }\n                    // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this\n                    if (isChallengeResponse(response)) {\n                        claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n                        if (claims) {\n                            let parsedClaim;\n                            try {\n                                parsedClaim = atob(claims);\n                            }\n                            catch (e) {\n                                logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                                return response;\n                            }\n                            shouldSendRequest = await authorizeRequestOnCaeChallenge({\n                                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                                response,\n                                request,\n                                getAccessToken,\n                                logger,\n                            }, parsedClaim);\n                            // Send updated request and handle response for RestError\n                            if (shouldSendRequest) {\n                                [response, error] = await trySendRequest(request, next);\n                            }\n                        }\n                    }\n                }\n            }\n            if (error) {\n                throw error;\n            }\n            else {\n                return response;\n            }\n        },\n    };\n}\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Pop e=\"f\", g=\"h\"`.\n * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.\n *\n * @internal\n */\nexport function parseChallenges(challenges) {\n    // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a=\"b\", c=d`\n    // The challenge regex captures parameteres with either quotes values or unquoted values\n    const challengeRegex = /(\\w+)\\s+((?:\\w+=(?:\"[^\"]*\"|[^,]*),?\\s*)+)/g;\n    // Parameter regex captures the claims group removed from the scheme in the format `a=\"b\"` and `c=\"d\"`\n    // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge\n    const paramRegex = /(\\w+)=\"([^\"]*)\"/g;\n    const parsedChallenges = [];\n    let match;\n    // Iterate over each challenge match\n    while ((match = challengeRegex.exec(challenges)) !== null) {\n        const scheme = match[1];\n        const paramsString = match[2];\n        const params = {};\n        let paramMatch;\n        // Iterate over each parameter match\n        while ((paramMatch = paramRegex.exec(paramsString)) !== null) {\n            params[paramMatch[1]] = paramMatch[2];\n        }\n        parsedChallenges.push({ scheme, params });\n    }\n    return parsedChallenges;\n}\n/**\n * Parse a pipeline response and look for a CAE challenge with \"Bearer\" scheme\n * Return the value in the header without parsing the challenge\n * @internal\n */\nfunction getCaeChallengeClaims(challenges) {\n    var _a;\n    if (!challenges) {\n        return;\n    }\n    // Find all challenges present in the header\n    const parsedChallenges = parseChallenges(challenges);\n    return (_a = parsedChallenges.find((x) => x.scheme === \"Bearer\" && x.params.claims && x.params.error === \"insufficient_claims\")) === null || _a === void 0 ? void 0 : _a.params.claims;\n}\n//# sourceMappingURL=bearerTokenAuthenticationPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\nasync function sendAuthorizeRequest(options) {\n    var _a, _b;\n    const { scopes, getAccessToken, request } = options;\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n    };\n    return (_b = (_a = (await getAccessToken(scopes, getTokenOptions))) === null || _a === void 0 ? void 0 : _a.token) !== null && _b !== void 0 ? _b : \"\";\n}\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nexport function auxiliaryAuthenticationHeaderPolicy(options) {\n    const { credentials, scopes } = options;\n    const logger = options.logger || coreLogger;\n    const tokenCyclerMap = new WeakMap();\n    return {\n        name: auxiliaryAuthenticationHeaderPolicyName,\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            if (!credentials || credentials.length === 0) {\n                logger.info(`${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);\n                return next(request);\n            }\n            const tokenPromises = [];\n            for (const credential of credentials) {\n                let getAccessToken = tokenCyclerMap.get(credential);\n                if (!getAccessToken) {\n                    getAccessToken = createTokenCycler(credential);\n                    tokenCyclerMap.set(credential, getAccessToken);\n                }\n                tokenPromises.push(sendAuthorizeRequest({\n                    scopes: Array.isArray(scopes) ? scopes : [scopes],\n                    request,\n                    getAccessToken,\n                    logger,\n                }));\n            }\n            const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));\n            if (auxiliaryTokens.length === 0) {\n                logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);\n                return next(request);\n            }\n            request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(\", \"));\n            return next(request);\n        },\n    };\n}\n//# sourceMappingURL=auxiliaryAuthenticationHeaderPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ALL_TENANTS, DeveloperSignOnClientId } from \"../constants.js\";\nimport { formatError } from \"./logging.js\";\nexport { processMultiTenantRequest } from \"./processMultiTenantRequest.js\";\n/**\n * @internal\n */\nexport function checkTenantId(logger, tenantId) {\n    if (!tenantId.match(/^[0-9a-zA-Z-.]+$/)) {\n        const error = new Error(\"Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://learn.microsoft.com/partner-center/find-ids-and-domain-names.\");\n        logger.info(formatError(\"\", error));\n        throw error;\n    }\n}\n/**\n * @internal\n */\nexport function resolveTenantId(logger, tenantId, clientId) {\n    if (tenantId) {\n        checkTenantId(logger, tenantId);\n        return tenantId;\n    }\n    if (!clientId) {\n        clientId = DeveloperSignOnClientId;\n    }\n    if (clientId !== DeveloperSignOnClientId) {\n        return \"common\";\n    }\n    return \"organizations\";\n}\n/**\n * @internal\n */\nexport function resolveAdditionallyAllowedTenantIds(additionallyAllowedTenants) {\n    if (!additionallyAllowedTenants || additionallyAllowedTenants.length === 0) {\n        return [];\n    }\n    if (additionallyAllowedTenants.includes(\"*\")) {\n        return ALL_TENANTS;\n    }\n    return additionallyAllowedTenants;\n}\n//# sourceMappingURL=tenantIdUtils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as base64 from \"./base64.js\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { isDuration, isValidUuid } from \"./utils.js\";\nclass SerializerImpl {\n    constructor(modelMappers = {}, isXML = false) {\n        this.modelMappers = modelMappers;\n        this.isXML = isXML;\n    }\n    /**\n     * @deprecated Removing the constraints validation on client side.\n     */\n    validateConstraints(mapper, value, objectName) {\n        const failValidation = (constraintName, constraintValue) => {\n            throw new Error(`\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`);\n        };\n        if (mapper.constraints && value !== undefined && value !== null) {\n            const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems, } = mapper.constraints;\n            if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n                failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n            }\n            if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n                failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n            }\n            if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n                failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n            }\n            if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n                failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n            }\n            if (MaxItems !== undefined && value.length > MaxItems) {\n                failValidation(\"MaxItems\", MaxItems);\n            }\n            if (MaxLength !== undefined && value.length > MaxLength) {\n                failValidation(\"MaxLength\", MaxLength);\n            }\n            if (MinItems !== undefined && value.length < MinItems) {\n                failValidation(\"MinItems\", MinItems);\n            }\n            if (MinLength !== undefined && value.length < MinLength) {\n                failValidation(\"MinLength\", MinLength);\n            }\n            if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n                failValidation(\"MultipleOf\", MultipleOf);\n            }\n            if (Pattern) {\n                const pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n                if (typeof value !== \"string\" || value.match(pattern) === null) {\n                    failValidation(\"Pattern\", Pattern);\n                }\n            }\n            if (UniqueItems &&\n                value.some((item, i, ar) => ar.indexOf(item) !== i)) {\n                failValidation(\"UniqueItems\", UniqueItems);\n            }\n        }\n    }\n    /**\n     * Serialize the given object based on its metadata defined in the mapper\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object\n     *\n     * @param object - A valid Javascript object to be serialized\n     *\n     * @param objectName - Name of the serialized object\n     *\n     * @param options - additional options to serialization\n     *\n     * @returns A valid serialized Javascript object\n     */\n    serialize(mapper, object, objectName, options = { xml: {} }) {\n        var _a, _b, _c;\n        const updatedOptions = {\n            xml: {\n                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,\n            },\n        };\n        let payload = {};\n        const mapperType = mapper.type.name;\n        if (!objectName) {\n            objectName = mapper.serializedName;\n        }\n        if (mapperType.match(/^Sequence$/i) !== null) {\n            payload = [];\n        }\n        if (mapper.isConstant) {\n            object = mapper.defaultValue;\n        }\n        // This table of allowed values should help explain\n        // the mapper.required and mapper.nullable properties.\n        // X means \"neither undefined or null are allowed\".\n        //           || required\n        //           || true      | false\n        //  nullable || ==========================\n        //      true || null      | undefined/null\n        //     false || X         | undefined\n        // undefined || X         | undefined/null\n        const { required, nullable } = mapper;\n        if (required && nullable && object === undefined) {\n            throw new Error(`${objectName} cannot be undefined.`);\n        }\n        if (required && !nullable && (object === undefined || object === null)) {\n            throw new Error(`${objectName} cannot be null or undefined.`);\n        }\n        if (!required && nullable === false && object === null) {\n            throw new Error(`${objectName} cannot be null.`);\n        }\n        if (object === undefined || object === null) {\n            payload = object;\n        }\n        else {\n            if (mapperType.match(/^any$/i) !== null) {\n                payload = object;\n            }\n            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n                payload = serializeBasicTypes(mapperType, objectName, object);\n            }\n            else if (mapperType.match(/^Enum$/i) !== null) {\n                const enumMapper = mapper;\n                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n            }\n            else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n                payload = serializeDateTypes(mapperType, object, objectName);\n            }\n            else if (mapperType.match(/^ByteArray$/i) !== null) {\n                payload = serializeByteArrayType(objectName, object);\n            }\n            else if (mapperType.match(/^Base64Url$/i) !== null) {\n                payload = serializeBase64UrlType(objectName, object);\n            }\n            else if (mapperType.match(/^Sequence$/i) !== null) {\n                payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n            else if (mapperType.match(/^Dictionary$/i) !== null) {\n                payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n            else if (mapperType.match(/^Composite$/i) !== null) {\n                payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n        }\n        return payload;\n    }\n    /**\n     * Deserialize the given object based on its metadata defined in the mapper\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object\n     *\n     * @param responseBody - A valid Javascript entity to be deserialized\n     *\n     * @param objectName - Name of the deserialized object\n     *\n     * @param options - Controls behavior of XML parser and builder.\n     *\n     * @returns A valid deserialized Javascript object\n     */\n    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {\n        var _a, _b, _c, _d;\n        const updatedOptions = {\n            xml: {\n                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,\n            },\n            ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false,\n        };\n        if (responseBody === undefined || responseBody === null) {\n            if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n                // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n                // between the list being empty versus being missing,\n                // so let's do the more user-friendly thing and return an empty list.\n                responseBody = [];\n            }\n            // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n            if (mapper.defaultValue !== undefined) {\n                responseBody = mapper.defaultValue;\n            }\n            return responseBody;\n        }\n        let payload;\n        const mapperType = mapper.type.name;\n        if (!objectName) {\n            objectName = mapper.serializedName;\n        }\n        if (mapperType.match(/^Composite$/i) !== null) {\n            payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n        }\n        else {\n            if (this.isXML) {\n                const xmlCharKey = updatedOptions.xml.xmlCharKey;\n                /**\n                 * If the mapper specifies this as a non-composite type value but the responseBody contains\n                 * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n                 * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n                 */\n                if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n                    responseBody = responseBody[xmlCharKey];\n                }\n            }\n            if (mapperType.match(/^Number$/i) !== null) {\n                payload = parseFloat(responseBody);\n                if (isNaN(payload)) {\n                    payload = responseBody;\n                }\n            }\n            else if (mapperType.match(/^Boolean$/i) !== null) {\n                if (responseBody === \"true\") {\n                    payload = true;\n                }\n                else if (responseBody === \"false\") {\n                    payload = false;\n                }\n                else {\n                    payload = responseBody;\n                }\n            }\n            else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n                payload = responseBody;\n            }\n            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n                payload = new Date(responseBody);\n            }\n            else if (mapperType.match(/^UnixTime$/i) !== null) {\n                payload = unixTimeToDate(responseBody);\n            }\n            else if (mapperType.match(/^ByteArray$/i) !== null) {\n                payload = base64.decodeString(responseBody);\n            }\n            else if (mapperType.match(/^Base64Url$/i) !== null) {\n                payload = base64UrlToByteArray(responseBody);\n            }\n            else if (mapperType.match(/^Sequence$/i) !== null) {\n                payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n            }\n            else if (mapperType.match(/^Dictionary$/i) !== null) {\n                payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n            }\n        }\n        if (mapper.isConstant) {\n            payload = mapper.defaultValue;\n        }\n        return payload;\n    }\n}\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\nexport function createSerializer(modelMappers = {}, isXML = false) {\n    return new SerializerImpl(modelMappers, isXML);\n}\nfunction trimEnd(str, ch) {\n    let len = str.length;\n    while (len - 1 >= 0 && str[len - 1] === ch) {\n        --len;\n    }\n    return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n    if (!buffer) {\n        return undefined;\n    }\n    if (!(buffer instanceof Uint8Array)) {\n        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n    }\n    // Uint8Array to Base64.\n    const str = base64.encodeByteArray(buffer);\n    // Base64 to Base64Url.\n    return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n    if (!str) {\n        return undefined;\n    }\n    if (str && typeof str.valueOf() !== \"string\") {\n        throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n    }\n    // Base64Url to Base64.\n    str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    // Base64 to Uint8Array.\n    return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n    const classes = [];\n    let partialclass = \"\";\n    if (prop) {\n        const subwords = prop.split(\".\");\n        for (const item of subwords) {\n            if (item.charAt(item.length - 1) === \"\\\\\") {\n                partialclass += item.substr(0, item.length - 1) + \".\";\n            }\n            else {\n                partialclass += item;\n                classes.push(partialclass);\n                partialclass = \"\";\n            }\n        }\n    }\n    return classes;\n}\nfunction dateToUnixTime(d) {\n    if (!d) {\n        return undefined;\n    }\n    if (typeof d.valueOf() === \"string\") {\n        d = new Date(d);\n    }\n    return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n    if (!n) {\n        return undefined;\n    }\n    return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n    if (value !== null && value !== undefined) {\n        if (typeName.match(/^Number$/i) !== null) {\n            if (typeof value !== \"number\") {\n                throw new Error(`${objectName} with value ${value} must be of type number.`);\n            }\n        }\n        else if (typeName.match(/^String$/i) !== null) {\n            if (typeof value.valueOf() !== \"string\") {\n                throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n            }\n        }\n        else if (typeName.match(/^Uuid$/i) !== null) {\n            if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n                throw new Error(`${objectName} with value \"${value}\" must be of type string and a valid uuid.`);\n            }\n        }\n        else if (typeName.match(/^Boolean$/i) !== null) {\n            if (typeof value !== \"boolean\") {\n                throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n            }\n        }\n        else if (typeName.match(/^Stream$/i) !== null) {\n            const objectType = typeof value;\n            if (objectType !== \"string\" &&\n                typeof value.pipe !== \"function\" && // NodeJS.ReadableStream\n                typeof value.tee !== \"function\" && // browser ReadableStream\n                !(value instanceof ArrayBuffer) &&\n                !ArrayBuffer.isView(value) &&\n                // File objects count as a type of Blob, so we want to use instanceof explicitly\n                !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) &&\n                objectType !== \"function\") {\n                throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);\n            }\n        }\n    }\n    return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n    if (!allowedValues) {\n        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);\n    }\n    const isPresent = allowedValues.some((item) => {\n        if (typeof item.valueOf() === \"string\") {\n            return item.toLowerCase() === value.toLowerCase();\n        }\n        return item === value;\n    });\n    if (!isPresent) {\n        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);\n    }\n    return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n    if (value !== undefined && value !== null) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error(`${objectName} must be of type Uint8Array.`);\n        }\n        value = base64.encodeByteArray(value);\n    }\n    return value;\n}\nfunction serializeBase64UrlType(objectName, value) {\n    if (value !== undefined && value !== null) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error(`${objectName} must be of type Uint8Array.`);\n        }\n        value = bufferToBase64Url(value);\n    }\n    return value;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n    if (value !== undefined && value !== null) {\n        if (typeName.match(/^Date$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n            }\n            value =\n                value instanceof Date\n                    ? value.toISOString().substring(0, 10)\n                    : new Date(value).toISOString().substring(0, 10);\n        }\n        else if (typeName.match(/^DateTime$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n            }\n            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n        }\n        else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n            }\n            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n        }\n        else if (typeName.match(/^UnixTime$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n                    `for it to be serialized in UnixTime/Epoch format.`);\n            }\n            value = dateToUnixTime(value);\n        }\n        else if (typeName.match(/^TimeSpan$/i) !== null) {\n            if (!isDuration(value)) {\n                throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`);\n            }\n        }\n    }\n    return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n    var _a;\n    if (!Array.isArray(object)) {\n        throw new Error(`${objectName} must be of type Array.`);\n    }\n    let elementType = mapper.type.element;\n    if (!elementType || typeof elementType !== \"object\") {\n        throw new Error(`element\" metadata for an Array must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}.`);\n    }\n    // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n    if (elementType.type.name === \"Composite\" && elementType.type.className) {\n        elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;\n    }\n    const tempArray = [];\n    for (let i = 0; i < object.length; i++) {\n        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n        if (isXml && elementType.xmlNamespace) {\n            const xmlnsKey = elementType.xmlNamespacePrefix\n                ? `xmlns:${elementType.xmlNamespacePrefix}`\n                : \"xmlns\";\n            if (elementType.type.name === \"Composite\") {\n                tempArray[i] = Object.assign({}, serializedValue);\n                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n            }\n            else {\n                tempArray[i] = {};\n                tempArray[i][options.xml.xmlCharKey] = serializedValue;\n                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n            }\n        }\n        else {\n            tempArray[i] = serializedValue;\n        }\n    }\n    return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n    if (typeof object !== \"object\") {\n        throw new Error(`${objectName} must be of type object.`);\n    }\n    const valueType = mapper.type.value;\n    if (!valueType || typeof valueType !== \"object\") {\n        throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}.`);\n    }\n    const tempDictionary = {};\n    for (const key of Object.keys(object)) {\n        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n        // If the element needs an XML namespace we need to add it within the $ property\n        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n    }\n    // Add the namespace to the root element if needed\n    if (isXml && mapper.xmlNamespace) {\n        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n        const result = tempDictionary;\n        result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n        return result;\n    }\n    return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n    const additionalProperties = mapper.type.additionalProperties;\n    if (!additionalProperties && mapper.type.className) {\n        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n        return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;\n    }\n    return additionalProperties;\n}\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n    const className = mapper.type.className;\n    if (!className) {\n        throw new Error(`Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(mapper, undefined, 2)}\".`);\n    }\n    return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n    let modelProps = mapper.type.modelProperties;\n    if (!modelProps) {\n        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n        if (!modelMapper) {\n            throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n        }\n        modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;\n        if (!modelProps) {\n            throw new Error(`modelProperties cannot be null or undefined in the ` +\n                `mapper \"${JSON.stringify(modelMapper)}\" of type \"${mapper.type.className}\" for object \"${objectName}\".`);\n        }\n    }\n    return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n        mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n    }\n    if (object !== undefined && object !== null) {\n        const payload = {};\n        const modelProps = resolveModelProperties(serializer, mapper, objectName);\n        for (const key of Object.keys(modelProps)) {\n            const propertyMapper = modelProps[key];\n            if (propertyMapper.readOnly) {\n                continue;\n            }\n            let propName;\n            let parentObject = payload;\n            if (serializer.isXML) {\n                if (propertyMapper.xmlIsWrapped) {\n                    propName = propertyMapper.xmlName;\n                }\n                else {\n                    propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n                }\n            }\n            else {\n                const paths = splitSerializeName(propertyMapper.serializedName);\n                propName = paths.pop();\n                for (const pathName of paths) {\n                    const childObject = parentObject[pathName];\n                    if ((childObject === undefined || childObject === null) &&\n                        ((object[key] !== undefined && object[key] !== null) ||\n                            propertyMapper.defaultValue !== undefined)) {\n                        parentObject[pathName] = {};\n                    }\n                    parentObject = parentObject[pathName];\n                }\n            }\n            if (parentObject !== undefined && parentObject !== null) {\n                if (isXml && mapper.xmlNamespace) {\n                    const xmlnsKey = mapper.xmlNamespacePrefix\n                        ? `xmlns:${mapper.xmlNamespacePrefix}`\n                        : \"xmlns\";\n                    parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });\n                }\n                const propertyObjectName = propertyMapper.serializedName !== \"\"\n                    ? objectName + \".\" + propertyMapper.serializedName\n                    : objectName;\n                let toSerialize = object[key];\n                const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n                if (polymorphicDiscriminator &&\n                    polymorphicDiscriminator.clientName === key &&\n                    (toSerialize === undefined || toSerialize === null)) {\n                    toSerialize = mapper.serializedName;\n                }\n                const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n                if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n                    const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n                    if (isXml && propertyMapper.xmlIsAttribute) {\n                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n                        // This keeps things simple while preventing name collision\n                        // with names in user documents.\n                        parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n                        parentObject[XML_ATTRKEY][propName] = serializedValue;\n                    }\n                    else if (isXml && propertyMapper.xmlIsWrapped) {\n                        parentObject[propName] = { [propertyMapper.xmlElementName]: value };\n                    }\n                    else {\n                        parentObject[propName] = value;\n                    }\n                }\n            }\n        }\n        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n        if (additionalPropertiesMapper) {\n            const propNames = Object.keys(modelProps);\n            for (const clientPropName in object) {\n                const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n                if (isAdditionalProperty) {\n                    payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n                }\n            }\n        }\n        return payload;\n    }\n    return object;\n}\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n    if (!isXml || !propertyMapper.xmlNamespace) {\n        return serializedValue;\n    }\n    const xmlnsKey = propertyMapper.xmlNamespacePrefix\n        ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n        : \"xmlns\";\n    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n    if ([\"Composite\"].includes(propertyMapper.type.name)) {\n        if (serializedValue[XML_ATTRKEY]) {\n            return serializedValue;\n        }\n        else {\n            const result = Object.assign({}, serializedValue);\n            result[XML_ATTRKEY] = xmlNamespace;\n            return result;\n        }\n    }\n    const result = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = xmlNamespace;\n    return result;\n}\nfunction isSpecialXmlProperty(propertyName, options) {\n    return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n    var _a, _b;\n    const xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n        mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n    }\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    let instance = {};\n    const handledPropertyNames = [];\n    for (const key of Object.keys(modelProps)) {\n        const propertyMapper = modelProps[key];\n        const paths = splitSerializeName(modelProps[key].serializedName);\n        handledPropertyNames.push(paths[0]);\n        const { serializedName, xmlName, xmlElementName } = propertyMapper;\n        let propertyObjectName = objectName;\n        if (serializedName !== \"\" && serializedName !== undefined) {\n            propertyObjectName = objectName + \".\" + serializedName;\n        }\n        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n            const dictionary = {};\n            for (const headerKey of Object.keys(responseBody)) {\n                if (headerKey.startsWith(headerCollectionPrefix)) {\n                    dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n                }\n                handledPropertyNames.push(headerKey);\n            }\n            instance[key] = dictionary;\n        }\n        else if (serializer.isXML) {\n            if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n                instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n            }\n            else if (propertyMapper.xmlIsMsText) {\n                if (responseBody[xmlCharKey] !== undefined) {\n                    instance[key] = responseBody[xmlCharKey];\n                }\n                else if (typeof responseBody === \"string\") {\n                    // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n                    //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n                    instance[key] = responseBody;\n                }\n            }\n            else {\n                const propertyName = xmlElementName || xmlName || serializedName;\n                if (propertyMapper.xmlIsWrapped) {\n                    /* a list of <xmlElementName> wrapped by <xmlName>\n                      For the xml example below\n                        <Cors>\n                          <CorsRule>...</CorsRule>\n                          <CorsRule>...</CorsRule>\n                        </Cors>\n                      the responseBody has\n                        {\n                          Cors: {\n                            CorsRule: [{...}, {...}]\n                          }\n                        }\n                      xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n                    */\n                    const wrapped = responseBody[xmlName];\n                    const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];\n                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n                    handledPropertyNames.push(xmlName);\n                }\n                else {\n                    const property = responseBody[propertyName];\n                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n                    handledPropertyNames.push(propertyName);\n                }\n            }\n        }\n        else {\n            // deserialize the property if it is present in the provided responseBody instance\n            let propertyInstance;\n            let res = responseBody;\n            // traversing the object step by step.\n            let steps = 0;\n            for (const item of paths) {\n                if (!res)\n                    break;\n                steps++;\n                res = res[item];\n            }\n            // only accept null when reaching the last position of object otherwise it would be undefined\n            if (res === null && steps < paths.length) {\n                res = undefined;\n            }\n            propertyInstance = res;\n            const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n            // checking that the model property name (key)(ex: \"fishtype\") and the\n            // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n            // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n            // is a better approach. The generator is not consistent with escaping '\\.' in the\n            // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n            // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n            // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n            // the transformation of model property name (ex: \"fishtype\") is done consistently.\n            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n            if (polymorphicDiscriminator &&\n                key === polymorphicDiscriminator.clientName &&\n                (propertyInstance === undefined || propertyInstance === null)) {\n                propertyInstance = mapper.serializedName;\n            }\n            let serializedValue;\n            // paging\n            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n                propertyInstance = responseBody[key];\n                const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n                // Copy over any properties that have already been added into the instance, where they do\n                // not exist on the newly de-serialized array\n                for (const [k, v] of Object.entries(instance)) {\n                    if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n                        arrayInstance[k] = v;\n                    }\n                }\n                instance = arrayInstance;\n            }\n            else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n                instance[key] = serializedValue;\n            }\n        }\n    }\n    const additionalPropertiesMapper = mapper.type.additionalProperties;\n    if (additionalPropertiesMapper) {\n        const isAdditionalProperty = (responsePropName) => {\n            for (const clientPropName in modelProps) {\n                const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n                if (paths[0] === responsePropName) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        for (const responsePropName in responseBody) {\n            if (isAdditionalProperty(responsePropName)) {\n                instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n            }\n        }\n    }\n    else if (responseBody && !options.ignoreUnknownProperties) {\n        for (const key of Object.keys(responseBody)) {\n            if (instance[key] === undefined &&\n                !handledPropertyNames.includes(key) &&\n                !isSpecialXmlProperty(key, options)) {\n                instance[key] = responseBody[key];\n            }\n        }\n    }\n    return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n    /* jshint validthis: true */\n    const value = mapper.type.value;\n    if (!value || typeof value !== \"object\") {\n        throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}`);\n    }\n    if (responseBody) {\n        const tempDictionary = {};\n        for (const key of Object.keys(responseBody)) {\n            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n        }\n        return tempDictionary;\n    }\n    return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n    var _a;\n    let element = mapper.type.element;\n    if (!element || typeof element !== \"object\") {\n        throw new Error(`element\" metadata for an Array must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}`);\n    }\n    if (responseBody) {\n        if (!Array.isArray(responseBody)) {\n            // xml2js will interpret a single element array as just the element, so force it to be an array\n            responseBody = [responseBody];\n        }\n        // Quirk: Composite mappers referenced by `element` might\n        // not have *all* properties declared (like uberParent),\n        // so let's try to look up the full definition by name.\n        if (element.type.name === \"Composite\" && element.type.className) {\n            element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;\n        }\n        const tempArray = [];\n        for (let i = 0; i < responseBody.length; i++) {\n            tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);\n        }\n        return tempArray;\n    }\n    return responseBody;\n}\nfunction getIndexDiscriminator(discriminators, discriminatorValue, typeName) {\n    const typeNamesToCheck = [typeName];\n    while (typeNamesToCheck.length) {\n        const currentName = typeNamesToCheck.shift();\n        const indexDiscriminator = discriminatorValue === currentName\n            ? discriminatorValue\n            : currentName + \".\" + discriminatorValue;\n        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n            return discriminators[indexDiscriminator];\n        }\n        else {\n            for (const [name, mapper] of Object.entries(discriminators)) {\n                if (name.startsWith(currentName + \".\") &&\n                    mapper.type.uberParent === currentName &&\n                    mapper.type.className) {\n                    typeNamesToCheck.push(mapper.type.className);\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n    var _a;\n    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n    if (polymorphicDiscriminator) {\n        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n        if (discriminatorName) {\n            // The serializedName might have \\\\, which we just want to ignore\n            if (polymorphicPropertyName === \"serializedName\") {\n                discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n            }\n            const discriminatorValue = object[discriminatorName];\n            const typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;\n            if (typeof discriminatorValue === \"string\" && typeName) {\n                const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);\n                if (polymorphicMapper) {\n                    mapper = polymorphicMapper;\n                }\n            }\n        }\n    }\n    return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n    return (mapper.type.polymorphicDiscriminator ||\n        getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n        getPolymorphicDiscriminatorSafely(serializer, mapper.type.className));\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n    return (typeName &&\n        serializer.modelMappers[typeName] &&\n        serializer.modelMappers[typeName].type.polymorphicDiscriminator);\n}\n/**\n * Known types of Mappers\n */\nexport const MapperTypeNames = {\n    Base64Url: \"Base64Url\",\n    Boolean: \"Boolean\",\n    ByteArray: \"ByteArray\",\n    Composite: \"Composite\",\n    Date: \"Date\",\n    DateTime: \"DateTime\",\n    DateTimeRfc1123: \"DateTimeRfc1123\",\n    Dictionary: \"Dictionary\",\n    Enum: \"Enum\",\n    Number: \"Number\",\n    Object: \"Object\",\n    Sequence: \"Sequence\",\n    String: \"String\",\n    Stream: \"Stream\",\n    TimeSpan: \"TimeSpan\",\n    UnixTime: \"UnixTime\",\n};\n//# sourceMappingURL=serializer.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Default key used to access the XML attributes.\n */\nexport const XML_ATTRKEY = \"$\";\n/**\n * Default key used to access the XML value content.\n */\nexport const XML_CHARKEY = \"_\";\n//# sourceMappingURL=interfaces.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Browser-only implementation of the module's state. The browser esm variant will not load the commonjs state, so we do not need to share state between the two.\n */\nexport const state = {\n    operationRequestMap: new WeakMap(),\n};\n//# sourceMappingURL=state-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { state } from \"./state.js\";\n/**\n * @internal\n * Retrieves the value to use for a given operation argument\n * @param operationArguments - The arguments passed from the generated client\n * @param parameter - The parameter description\n * @param fallbackObject - If something isn't found in the arguments bag, look here.\n *  Generally used to look at the service client properties.\n */\nexport function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {\n    let parameterPath = parameter.parameterPath;\n    const parameterMapper = parameter.mapper;\n    let value;\n    if (typeof parameterPath === \"string\") {\n        parameterPath = [parameterPath];\n    }\n    if (Array.isArray(parameterPath)) {\n        if (parameterPath.length > 0) {\n            if (parameterMapper.isConstant) {\n                value = parameterMapper.defaultValue;\n            }\n            else {\n                let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n                if (!propertySearchResult.propertyFound && fallbackObject) {\n                    propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);\n                }\n                let useDefaultValue = false;\n                if (!propertySearchResult.propertyFound) {\n                    useDefaultValue =\n                        parameterMapper.required ||\n                            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n                }\n                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n            }\n        }\n    }\n    else {\n        if (parameterMapper.required) {\n            value = {};\n        }\n        for (const propertyName in parameterPath) {\n            const propertyMapper = parameterMapper.type.modelProperties[propertyName];\n            const propertyPath = parameterPath[propertyName];\n            const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {\n                parameterPath: propertyPath,\n                mapper: propertyMapper,\n            }, fallbackObject);\n            if (propertyValue !== undefined) {\n                if (!value) {\n                    value = {};\n                }\n                value[propertyName] = propertyValue;\n            }\n        }\n    }\n    return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n    const result = { propertyFound: false };\n    let i = 0;\n    for (; i < parameterPath.length; ++i) {\n        const parameterPathPart = parameterPath[i];\n        // Make sure to check inherited properties too, so don't use hasOwnProperty().\n        if (parent && parameterPathPart in parent) {\n            parent = parent[parameterPathPart];\n        }\n        else {\n            break;\n        }\n    }\n    if (i === parameterPath.length) {\n        result.propertyValue = parent;\n        result.propertyFound = true;\n    }\n    return result;\n}\nconst originalRequestSymbol = Symbol.for(\"@azure/core-client original request\");\nfunction hasOriginalRequest(request) {\n    return originalRequestSymbol in request;\n}\nexport function getOperationRequestInfo(request) {\n    if (hasOriginalRequest(request)) {\n        return getOperationRequestInfo(request[originalRequestSymbol]);\n    }\n    let info = state.operationRequestMap.get(request);\n    if (!info) {\n        info = {};\n        state.operationRequestMap.set(request, info);\n    }\n    return info;\n}\n//# sourceMappingURL=operationHelpers.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_CHARKEY } from \"./interfaces.js\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options = {}) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n    const parseXML = options.parseXML;\n    const serializerOptions = options.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n            includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n            xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY,\n        },\n    };\n    return {\n        name: deserializationPolicyName,\n        async sendRequest(request, next) {\n            const response = await next(request);\n            return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n        },\n    };\n}\nfunction getOperationResponseMap(parsedResponse) {\n    let result;\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (operationSpec) {\n        if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n            result = operationSpec.responses[parsedResponse.status];\n        }\n        else {\n            result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n        }\n    }\n    return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n    let result;\n    if (shouldDeserialize === undefined) {\n        result = true;\n    }\n    else if (typeof shouldDeserialize === \"boolean\") {\n        result = shouldDeserialize;\n    }\n    else {\n        result = shouldDeserialize(parsedResponse);\n    }\n    return result;\n}\nasync function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n    if (!shouldDeserializeResponse(parsedResponse)) {\n        return parsedResponse;\n    }\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (!operationSpec || !operationSpec.responses) {\n        return parsedResponse;\n    }\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);\n    if (error) {\n        throw error;\n    }\n    else if (shouldReturnResponse) {\n        return parsedResponse;\n    }\n    // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n    if (responseSpec) {\n        if (responseSpec.bodyMapper) {\n            let valueToDeserialize = parsedResponse.parsedBody;\n            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n                valueToDeserialize =\n                    typeof valueToDeserialize === \"object\"\n                        ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]\n                        : [];\n            }\n            try {\n                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n            }\n            catch (deserializeError) {\n                const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n                    statusCode: parsedResponse.status,\n                    request: parsedResponse.request,\n                    response: parsedResponse,\n                });\n                throw restError;\n            }\n        }\n        else if (operationSpec.httpMethod === \"HEAD\") {\n            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n        }\n        if (responseSpec.headersMapper) {\n            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", { xml: {}, ignoreUnknownProperties: true });\n        }\n    }\n    return parsedResponse;\n}\nfunction isOperationSpecEmpty(operationSpec) {\n    const expectedStatusCodes = Object.keys(operationSpec.responses);\n    return (expectedStatusCodes.length === 0 ||\n        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\"));\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n    var _a, _b, _c, _d, _e;\n    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)\n        ? isSuccessByStatus\n        : !!responseSpec;\n    if (isExpectedStatusCode) {\n        if (responseSpec) {\n            if (!responseSpec.isError) {\n                return { error: null, shouldReturnResponse: false };\n            }\n        }\n        else {\n            return { error: null, shouldReturnResponse: false };\n        }\n    }\n    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status))\n        ? `Unexpected status code: ${parsedResponse.status}`\n        : parsedResponse.bodyAsText;\n    const error = new RestError(initialErrorMessage, {\n        statusCode: parsedResponse.status,\n        request: parsedResponse.request,\n        response: parsedResponse,\n    });\n    // If the item failed but there's no error spec or default spec to deserialize the error,\n    // and the parsed body doesn't look like an error object,\n    // we should fail so we just throw the parsed response\n    if (!errorResponseSpec &&\n        !(((_c = (_b = parsedResponse.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.code) && ((_e = (_d = parsedResponse.parsedBody) === null || _d === void 0 ? void 0 : _d.error) === null || _e === void 0 ? void 0 : _e.message))) {\n        throw error;\n    }\n    const defaultBodyMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.bodyMapper;\n    const defaultHeadersMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.headersMapper;\n    try {\n        // If error response has a body, try to deserialize it using default body mapper.\n        // Then try to extract error code & message from it\n        if (parsedResponse.parsedBody) {\n            const parsedBody = parsedResponse.parsedBody;\n            let deserializedError;\n            if (defaultBodyMapper) {\n                let valueToDeserialize = parsedBody;\n                if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n                    valueToDeserialize = [];\n                    const elementName = defaultBodyMapper.xmlElementName;\n                    if (typeof parsedBody === \"object\" && elementName) {\n                        valueToDeserialize = parsedBody[elementName];\n                    }\n                }\n                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n            }\n            const internalError = parsedBody.error || deserializedError || parsedBody;\n            error.code = internalError.code;\n            if (internalError.message) {\n                error.message = internalError.message;\n            }\n            if (defaultBodyMapper) {\n                error.response.parsedBody = deserializedError;\n            }\n        }\n        // If error response has headers, try to deserialize it using default header mapper\n        if (parsedResponse.headers && defaultHeadersMapper) {\n            error.response.parsedHeaders =\n                operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n        }\n    }\n    catch (defaultError) {\n        error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n    }\n    return { error, shouldReturnResponse: false };\n}\nasync function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) &&\n        operationResponse.bodyAsText) {\n        const text = operationResponse.bodyAsText;\n        const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n        const contentComponents = !contentType\n            ? []\n            : contentType.split(\";\").map((component) => component.toLowerCase());\n        try {\n            if (contentComponents.length === 0 ||\n                contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {\n                operationResponse.parsedBody = JSON.parse(text);\n                return operationResponse;\n            }\n            else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n                if (!parseXML) {\n                    throw new Error(\"Parsing XML not supported.\");\n                }\n                const body = await parseXML(text, opts.xml);\n                operationResponse.parsedBody = body;\n                return operationResponse;\n            }\n        }\n        catch (err) {\n            const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n            const errCode = err.code || RestError.PARSE_ERROR;\n            const e = new RestError(msg, {\n                code: errCode,\n                statusCode: operationResponse.status,\n                request: operationResponse.request,\n                response: operationResponse,\n            });\n            throw e;\n        }\n    }\n    return operationResponse;\n}\n//# sourceMappingURL=deserializationPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { MapperTypeNames } from \"./serializer.js\";\n/**\n * Gets the list of status codes for streaming responses.\n * @internal\n */\nexport function getStreamingResponseStatusCodes(operationSpec) {\n    const result = new Set();\n    for (const statusCode in operationSpec.responses) {\n        const operationResponse = operationSpec.responses[statusCode];\n        if (operationResponse.bodyMapper &&\n            operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {\n            result.add(Number(statusCode));\n        }\n    }\n    return result;\n}\n/**\n * Get the path to this parameter's value as a dotted string (a.b.c).\n * @param parameter - The parameter to get the path string for.\n * @returns The path to this parameter's value as a dotted string.\n * @internal\n */\nexport function getPathStringFromParameter(parameter) {\n    const { parameterPath, mapper } = parameter;\n    let result;\n    if (typeof parameterPath === \"string\") {\n        result = parameterPath;\n    }\n    else if (Array.isArray(parameterPath)) {\n        result = parameterPath.join(\".\");\n    }\n    else {\n        result = mapper.serializedName;\n    }\n    return result;\n}\n//# sourceMappingURL=interfaceHelpers.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo, } from \"./operationHelpers.js\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options = {}) {\n    const stringifyXML = options.stringifyXML;\n    return {\n        name: serializationPolicyName,\n        async sendRequest(request, next) {\n            const operationInfo = getOperationRequestInfo(request);\n            const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n            const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n            if (operationSpec && operationArguments) {\n                serializeHeaders(request, operationArguments, operationSpec);\n                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n            }\n            return next(request);\n        },\n    };\n}\n/**\n * @internal\n */\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n    var _a, _b;\n    if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n            let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n            if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {\n                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n                const headerCollectionPrefix = headerParameter.mapper\n                    .headerCollectionPrefix;\n                if (headerCollectionPrefix) {\n                    for (const key of Object.keys(headerValue)) {\n                        request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                    }\n                }\n                else {\n                    request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n                }\n            }\n        }\n    }\n    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n    if (customHeaders) {\n        for (const customHeaderName of Object.keys(customHeaders)) {\n            request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n        }\n    }\n}\n/**\n * @internal\n */\nexport function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {\n    throw new Error(\"XML serialization unsupported!\");\n}) {\n    var _a, _b, _c, _d, _e;\n    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n            includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n            xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY,\n        },\n    };\n    const xmlCharKey = updatedOptions.xml.xmlCharKey;\n    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n        request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n        const bodyMapper = operationSpec.requestBody.mapper;\n        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable, } = bodyMapper;\n        const typeName = bodyMapper.type.name;\n        try {\n            if ((request.body !== undefined && request.body !== null) ||\n                (nullable && request.body === null) ||\n                required) {\n                const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n                request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n                const isStream = typeName === MapperTypeNames.Stream;\n                if (operationSpec.isXML) {\n                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n                    if (typeName === MapperTypeNames.Sequence) {\n                        request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });\n                    }\n                    else if (!isStream) {\n                        request.body = stringifyXML(value, {\n                            rootName: xmlName || serializedName,\n                            xmlCharKey,\n                        });\n                    }\n                }\n                else if (typeName === MapperTypeNames.String &&\n                    (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n                    // the String serializer has validated that request body is a string\n                    // so just send the string.\n                    return;\n                }\n                else if (!isStream) {\n                    request.body = JSON.stringify(request.body);\n                }\n            }\n        }\n        catch (error) {\n            throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n        }\n    }\n    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n        request.formData = {};\n        for (const formDataParameter of operationSpec.formDataParameters) {\n            const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n                request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n            }\n        }\n    }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n    // Composite and Sequence schemas already got their root namespace set during serialization\n    // We just need to add xmlns to the other schema types\n    if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n        const result = {};\n        result[options.xml.xmlCharKey] = serializedValue;\n        result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n        return result;\n    }\n    return serializedValue;\n}\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n    if (!Array.isArray(obj)) {\n        obj = [obj];\n    }\n    if (!xmlNamespaceKey || !xmlNamespace) {\n        return { [elementName]: obj };\n    }\n    const result = { [elementName]: obj };\n    result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };\n    return result;\n}\n//# sourceMappingURL=serializationPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { deserializationPolicy } from \"./deserializationPolicy.js\";\nimport { bearerTokenAuthenticationPolicy, createPipelineFromOptions, } from \"@azure/core-rest-pipeline\";\nimport { serializationPolicy } from \"./serializationPolicy.js\";\n/**\n * Creates a new Pipeline for use with a Service Client.\n * Adds in deserializationPolicy by default.\n * Also adds in bearerTokenAuthenticationPolicy if passed a TokenCredential.\n * @param options - Options to customize the created pipeline.\n */\nexport function createClientPipeline(options = {}) {\n    const pipeline = createPipelineFromOptions(options !== null && options !== void 0 ? options : {});\n    if (options.credentialOptions) {\n        pipeline.addPolicy(bearerTokenAuthenticationPolicy({\n            credential: options.credentialOptions.credential,\n            scopes: options.credentialOptions.credentialScopes,\n        }));\n    }\n    pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: \"Serialize\" });\n    pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {\n        phase: \"Deserialize\",\n    });\n    return pipeline;\n}\n//# sourceMappingURL=pipeline.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n    return (mapperTypeName !== \"Composite\" &&\n        mapperTypeName !== \"Dictionary\" &&\n        (typeof value === \"string\" ||\n            typeof value === \"number\" ||\n            typeof value === \"boolean\" ||\n            (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !==\n                null ||\n            value === undefined ||\n            value === null));\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value) {\n    return validateISODuration.test(value);\n}\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid) {\n    return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);\n    if (responseObject.hasNullableType &&\n        Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n        return responseObject.shouldWrapBody ? { body: null } : null;\n    }\n    else {\n        return responseObject.shouldWrapBody\n            ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;\n    }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(fullResponse, responseSpec) {\n    var _a, _b;\n    const parsedHeaders = fullResponse.parsedHeaders;\n    // head methods never have a body, but we return a boolean set to body property\n    // to indicate presence/absence of the resource\n    if (fullResponse.request.method === \"HEAD\") {\n        return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });\n    }\n    const bodyMapper = responseSpec && responseSpec.bodyMapper;\n    const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);\n    const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;\n    /** If the body is asked for, we look at the expected body type to handle it */\n    if (expectedBodyTypeName === \"Stream\") {\n        return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });\n    }\n    const modelProperties = (expectedBodyTypeName === \"Composite\" &&\n        bodyMapper.type.modelProperties) ||\n        {};\n    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === \"\");\n    if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n        const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];\n        for (const key of Object.keys(modelProperties)) {\n            if (modelProperties[key].serializedName) {\n                arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];\n            }\n        }\n        if (parsedHeaders) {\n            for (const key of Object.keys(parsedHeaders)) {\n                arrayResponse[key] = parsedHeaders[key];\n            }\n        }\n        return isNullable &&\n            !fullResponse.parsedBody &&\n            !parsedHeaders &&\n            Object.getOwnPropertyNames(modelProperties).length === 0\n            ? null\n            : arrayResponse;\n    }\n    return handleNullableResponseAndWrappableBody({\n        body: fullResponse.parsedBody,\n        headers: parsedHeaders,\n        hasNullableType: isNullable,\n        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),\n    });\n}\n//# sourceMappingURL=utils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createDefaultHttpClient } from \"@azure/core-rest-pipeline\";\nlet cachedHttpClient;\nexport function getCachedDefaultHttpClient() {\n    if (!cachedHttpClient) {\n        cachedHttpClient = createDefaultHttpClient();\n    }\n    return cachedHttpClient;\n}\n//# sourceMappingURL=httpClientCache.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\nconst CollectionFormatToDelimiterMap = {\n    CSV: \",\",\n    SSV: \" \",\n    Multi: \"Multi\",\n    TSV: \"\\t\",\n    Pipes: \"|\",\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n    let isAbsolutePath = false;\n    let requestUrl = replaceAll(baseUri, urlReplacements);\n    if (operationSpec.path) {\n        let path = replaceAll(operationSpec.path, urlReplacements);\n        // QUIRK: sometimes we get a path component like /{nextLink}\n        // which may be a fully formed URL with a leading /. In that case, we should\n        // remove the leading /\n        if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        // QUIRK: sometimes we get a path component like {nextLink}\n        // which may be a fully formed URL. In that case, we should\n        // ignore the baseUri.\n        if (isAbsoluteUrl(path)) {\n            requestUrl = path;\n            isAbsolutePath = true;\n        }\n        else {\n            requestUrl = appendPath(requestUrl, path);\n        }\n    }\n    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n    /**\n     * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n     * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n     * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n     * is still being built so there is nothing to overwrite.\n     */\n    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n    return requestUrl;\n}\nfunction replaceAll(input, replacements) {\n    let result = input;\n    for (const [searchValue, replaceValue] of replacements) {\n        result = result.split(searchValue).join(replaceValue);\n    }\n    return result;\n}\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n    var _a;\n    const result = new Map();\n    if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n        for (const urlParameter of operationSpec.urlParameters) {\n            let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n            const parameterPathString = getPathStringFromParameter(urlParameter);\n            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n            if (!urlParameter.skipEncoding) {\n                urlParameterValue = encodeURIComponent(urlParameterValue);\n            }\n            result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);\n        }\n    }\n    return result;\n}\nfunction isAbsoluteUrl(url) {\n    return url.includes(\"://\");\n}\nfunction appendPath(url, pathToAppend) {\n    if (!pathToAppend) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    let newPath = parsedUrl.pathname;\n    if (!newPath.endsWith(\"/\")) {\n        newPath = `${newPath}/`;\n    }\n    if (pathToAppend.startsWith(\"/\")) {\n        pathToAppend = pathToAppend.substring(1);\n    }\n    const searchStart = pathToAppend.indexOf(\"?\");\n    if (searchStart !== -1) {\n        const path = pathToAppend.substring(0, searchStart);\n        const search = pathToAppend.substring(searchStart + 1);\n        newPath = newPath + path;\n        if (search) {\n            parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n        }\n    }\n    else {\n        newPath = newPath + pathToAppend;\n    }\n    parsedUrl.pathname = newPath;\n    return parsedUrl.toString();\n}\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n    var _a;\n    const result = new Map();\n    const sequenceParams = new Set();\n    if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n        for (const queryParameter of operationSpec.queryParameters) {\n            if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n                sequenceParams.add(queryParameter.mapper.serializedName);\n            }\n            let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n            if ((queryParameterValue !== undefined && queryParameterValue !== null) ||\n                queryParameter.mapper.required) {\n                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n                const delimiter = queryParameter.collectionFormat\n                    ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]\n                    : \"\";\n                if (Array.isArray(queryParameterValue)) {\n                    // replace null and undefined\n                    queryParameterValue = queryParameterValue.map((item) => {\n                        if (item === null || item === undefined) {\n                            return \"\";\n                        }\n                        return item;\n                    });\n                }\n                if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n                    continue;\n                }\n                else if (Array.isArray(queryParameterValue) &&\n                    (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n                    queryParameterValue = queryParameterValue.join(delimiter);\n                }\n                if (!queryParameter.skipEncoding) {\n                    if (Array.isArray(queryParameterValue)) {\n                        queryParameterValue = queryParameterValue.map((item) => {\n                            return encodeURIComponent(item);\n                        });\n                    }\n                    else {\n                        queryParameterValue = encodeURIComponent(queryParameterValue);\n                    }\n                }\n                // Join pipes and CSV *after* encoding, or the server will be upset.\n                if (Array.isArray(queryParameterValue) &&\n                    (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n                    queryParameterValue = queryParameterValue.join(delimiter);\n                }\n                result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n            }\n        }\n    }\n    return {\n        queryParams: result,\n        sequenceParams,\n    };\n}\nfunction simpleParseQueryParams(queryString) {\n    const result = new Map();\n    if (!queryString || queryString[0] !== \"?\") {\n        return result;\n    }\n    // remove the leading ?\n    queryString = queryString.slice(1);\n    const pairs = queryString.split(\"&\");\n    for (const pair of pairs) {\n        const [name, value] = pair.split(\"=\", 2);\n        const existingValue = result.get(name);\n        if (existingValue) {\n            if (Array.isArray(existingValue)) {\n                existingValue.push(value);\n            }\n            else {\n                result.set(name, [existingValue, value]);\n            }\n        }\n        else {\n            result.set(name, value);\n        }\n    }\n    return result;\n}\n/** @internal */\nexport function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {\n    if (queryParams.size === 0) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n    // can change their meaning to the server, such as in the case of a SAS signature.\n    // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n    const combinedParams = simpleParseQueryParams(parsedUrl.search);\n    for (const [name, value] of queryParams) {\n        const existingValue = combinedParams.get(name);\n        if (Array.isArray(existingValue)) {\n            if (Array.isArray(value)) {\n                existingValue.push(...value);\n                const valueSet = new Set(existingValue);\n                combinedParams.set(name, Array.from(valueSet));\n            }\n            else {\n                existingValue.push(value);\n            }\n        }\n        else if (existingValue) {\n            if (Array.isArray(value)) {\n                value.unshift(existingValue);\n            }\n            else if (sequenceParams.has(name)) {\n                combinedParams.set(name, [existingValue, value]);\n            }\n            if (!noOverwrite) {\n                combinedParams.set(name, value);\n            }\n        }\n        else {\n            combinedParams.set(name, value);\n        }\n    }\n    const searchPieces = [];\n    for (const [name, value] of combinedParams) {\n        if (typeof value === \"string\") {\n            searchPieces.push(`${name}=${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // QUIRK: If we get an array of values, include multiple key/value pairs\n            for (const subValue of value) {\n                searchPieces.push(`${name}=${subValue}`);\n            }\n        }\n        else {\n            searchPieces.push(`${name}=${value}`);\n        }\n    }\n    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n    parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n    return parsedUrl.toString();\n}\n//# sourceMappingURL=urlHelpers.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-client\");\n//# sourceMappingURL=log.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n    /**\n     * The ServiceClient constructor\n     * @param options - The service client options that govern the behavior of the client.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        this._requestContentType = options.requestContentType;\n        this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n        if (options.baseUri) {\n            logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n        }\n        this._allowInsecureConnection = options.allowInsecureConnection;\n        this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n        this.pipeline = options.pipeline || createDefaultPipeline(options);\n        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n            for (const { policy, position } of options.additionalPolicies) {\n                // Sign happens after Retry and is commonly needed to occur\n                // before policies that intercept post-retry.\n                const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n                this.pipeline.addPolicy(policy, {\n                    afterPhase,\n                });\n            }\n        }\n    }\n    /**\n     * Send the provided httpRequest.\n     */\n    async sendRequest(request) {\n        return this.pipeline.sendRequest(this._httpClient, request);\n    }\n    /**\n     * Send an HTTP request that is populated using the provided OperationSpec.\n     * @typeParam T - The typed result of the request, based on the OperationSpec.\n     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n     * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n     */\n    async sendOperationRequest(operationArguments, operationSpec) {\n        const endpoint = operationSpec.baseUrl || this._endpoint;\n        if (!endpoint) {\n            throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n        }\n        // Templatized URLs sometimes reference properties on the ServiceClient child class,\n        // so we have to pass `this` below in order to search these properties if they're\n        // not part of OperationArguments\n        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n        const request = createPipelineRequest({\n            url,\n        });\n        request.method = operationSpec.httpMethod;\n        const operationInfo = getOperationRequestInfo(request);\n        operationInfo.operationSpec = operationSpec;\n        operationInfo.operationArguments = operationArguments;\n        const contentType = operationSpec.contentType || this._requestContentType;\n        if (contentType && operationSpec.requestBody) {\n            request.headers.set(\"Content-Type\", contentType);\n        }\n        const options = operationArguments.options;\n        if (options) {\n            const requestOptions = options.requestOptions;\n            if (requestOptions) {\n                if (requestOptions.timeout) {\n                    request.timeout = requestOptions.timeout;\n                }\n                if (requestOptions.onUploadProgress) {\n                    request.onUploadProgress = requestOptions.onUploadProgress;\n                }\n                if (requestOptions.onDownloadProgress) {\n                    request.onDownloadProgress = requestOptions.onDownloadProgress;\n                }\n                if (requestOptions.shouldDeserialize !== undefined) {\n                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n                }\n                if (requestOptions.allowInsecureConnection) {\n                    request.allowInsecureConnection = true;\n                }\n            }\n            if (options.abortSignal) {\n                request.abortSignal = options.abortSignal;\n            }\n            if (options.tracingOptions) {\n                request.tracingOptions = options.tracingOptions;\n            }\n        }\n        if (this._allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n        }\n        if (request.streamResponseStatusCodes === undefined) {\n            request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n        }\n        try {\n            const rawResponse = await this.sendRequest(request);\n            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n            if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                options.onResponse(rawResponse, flatResponse);\n            }\n            return flatResponse;\n        }\n        catch (error) {\n            if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n                const rawResponse = error.response;\n                const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n                error.details = flatResponse;\n                if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                    options.onResponse(rawResponse, flatResponse, error);\n                }\n            }\n            throw error;\n        }\n    }\n}\nfunction createDefaultPipeline(options) {\n    const credentialScopes = getCredentialScopes(options);\n    const credentialOptions = options.credential && credentialScopes\n        ? { credentialScopes, credential: options.credential }\n        : undefined;\n    return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));\n}\nfunction getCredentialScopes(options) {\n    if (options.credentialScopes) {\n        return options.credentialScopes;\n    }\n    if (options.endpoint) {\n        return `${options.endpoint}/.default`;\n    }\n    if (options.baseUri) {\n        return `${options.baseUri}/.default`;\n    }\n    if (options.credential && !options.credentialScopes) {\n        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n    }\n    return undefined;\n}\n//# sourceMappingURL=serviceClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { logger as coreClientLogger } from \"./log.js\";\nimport { decodeStringToString } from \"./base64.js\";\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Bearer d=\"e\", f=\"g\"`.\n * Into: `[ { a: 'b', c: 'd' }, { d: 'e', f: 'g' } ]`.\n *\n * @internal\n */\nexport function parseCAEChallenge(challenges) {\n    const bearerChallenges = `, ${challenges.trim()}`.split(\", Bearer \").filter((x) => x);\n    return bearerChallenges.map((challenge) => {\n        const challengeParts = `${challenge.trim()}, `.split('\", ').filter((x) => x);\n        const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('=\"')));\n        // Key-value pairs to plain object:\n        return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});\n    });\n}\n/**\n * This function can be used as a callback for the `bearerTokenAuthenticationPolicy` of `@azure/core-rest-pipeline`, to support CAE challenges:\n * [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation).\n *\n * Call the `bearerTokenAuthenticationPolicy` with the following options:\n *\n * ```ts snippet:AuthorizeRequestOnClaimChallenge\n * import { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\n * import { authorizeRequestOnClaimChallenge } from \"@azure/core-client\";\n *\n * const policy = bearerTokenAuthenticationPolicy({\n *   challengeCallbacks: {\n *     authorizeRequestOnChallenge: authorizeRequestOnClaimChallenge,\n *   },\n *   scopes: [\"https://service/.default\"],\n * });\n * ```\n *\n * Once provided, the `bearerTokenAuthenticationPolicy` policy will internally handle Continuous Access Evaluation (CAE) challenges.\n * When it can't complete a challenge it will return the 401 (unauthorized) response from ARM.\n *\n * Example challenge with claims:\n *\n * ```\n * Bearer authorization_uri=\"https://login.windows-ppe.net/\", error=\"invalid_token\",\n * error_description=\"User session has been revoked\",\n * claims=\"eyJhY2Nlc3NfdG9rZW4iOnsibmJmIjp7ImVzc2VudGlhbCI6dHJ1ZSwgInZhbHVlIjoiMTYwMzc0MjgwMCJ9fX0=\"\n * ```\n */\nexport async function authorizeRequestOnClaimChallenge(onChallengeOptions) {\n    var _a;\n    const { scopes, response } = onChallengeOptions;\n    const logger = onChallengeOptions.logger || coreClientLogger;\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n        logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);\n        return false;\n    }\n    const challenges = parseCAEChallenge(challenge) || [];\n    const parsedChallenge = challenges.find((x) => x.claims);\n    if (!parsedChallenge) {\n        logger.info(`The WWW-Authenticate header was missing the necessary \"claims\" to perform the Continuous Access Evaluation authentication flow.`);\n        return false;\n    }\n    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {\n        claims: decodeStringToString(parsedChallenge.claims),\n    });\n    if (!accessToken) {\n        return false;\n    }\n    onChallengeOptions.request.headers.set(\"Authorization\", `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n    return true;\n}\n//# sourceMappingURL=authorizeRequestOnClaimChallenge.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n    DefaultScope: \"/.default\",\n    /**\n     * Defines constants for use with HTTP headers.\n     */\n    HeaderConstants: {\n        /**\n         * The Authorization header.\n         */\n        AUTHORIZATION: \"authorization\",\n    },\n};\nfunction isUuid(text) {\n    return /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/.test(text);\n}\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://learn.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge = async (challengeOptions) => {\n    var _a;\n    const requestOptions = requestToOptions(challengeOptions.request);\n    const challenge = getChallenge(challengeOptions.response);\n    if (challenge) {\n        const challengeInfo = parseChallenge(challenge);\n        const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n        const tenantId = extractTenantId(challengeInfo);\n        if (!tenantId) {\n            return false;\n        }\n        const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));\n        if (!accessToken) {\n            return false;\n        }\n        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n        return true;\n    }\n    return false;\n};\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo) {\n    const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n    const pathSegments = parsedAuthUri.pathname.split(\"/\");\n    const tenantId = pathSegments[1];\n    if (tenantId && isUuid(tenantId)) {\n        return tenantId;\n    }\n    return undefined;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(challengeOptions, challengeInfo) {\n    if (!challengeInfo.resource_id) {\n        return challengeOptions.scopes;\n    }\n    const challengeScopes = new URL(challengeInfo.resource_id);\n    challengeScopes.pathname = Constants.DefaultScope;\n    let scope = challengeScopes.toString();\n    if (scope === \"https://disk.azure.com/.default\") {\n        // the extra slash is required by the service\n        scope = \"https://disk.azure.com//.default\";\n    }\n    return [scope];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (response.status === 401 && challenge) {\n        return challenge;\n    }\n    return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge) {\n    const bearerChallenge = challenge.slice(\"Bearer \".length);\n    const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter((x) => x);\n    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split(\"=\")));\n    // Key-value pairs to plain object:\n    return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request) {\n    return {\n        abortSignal: request.abortSignal,\n        requestOptions: {\n            timeout: request.timeout,\n        },\n        tracingOptions: request.tracingOptions,\n    };\n}\n//# sourceMappingURL=authorizeRequestOnTenantChallenge.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport function getIdentityTokenEndpointSuffix(tenantId) {\n    if (tenantId === \"adfs\") {\n        return \"oauth2/token\";\n    }\n    else {\n        return \"oauth2/v2.0/token\";\n    }\n}\n//# sourceMappingURL=identityTokenEndpoint.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nconst DefaultScopeSuffix = \"/.default\";\n/**\n * Error message for Service Fabric Managed Identity environment.\n */\nexport const serviceFabricErrorMessage = \"Specifying a `clientId` or `resourceId` is not supported by the Service Fabric managed identity environment. The managed identity configuration is determined by the Service Fabric cluster resource configuration. See https://aka.ms/servicefabricmi for more information\";\n/**\n * Most MSIs send requests to the IMDS endpoint, or a similar endpoint.\n * These are GET requests that require sending a `resource` parameter on the query.\n * This resource can be derived from the scopes received through the getToken call, as long as only one scope is received.\n * Multiple scopes assume that the resulting token will have access to multiple resources, which won't be the case.\n *\n * For that reason, when we encounter multiple scopes, we return undefined.\n * It's up to the individual MSI implementations to throw the errors (which helps us provide less generic errors).\n */\nexport function mapScopesToResource(scopes) {\n    let scope = \"\";\n    if (Array.isArray(scopes)) {\n        if (scopes.length !== 1) {\n            return;\n        }\n        scope = scopes[0];\n    }\n    else if (typeof scopes === \"string\") {\n        scope = scopes;\n    }\n    if (!scope.endsWith(DefaultScopeSuffix)) {\n        return scope;\n    }\n    return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));\n}\n/**\n * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.\n * @param body - A parsed response body from the authentication endpoint.\n */\nexport function parseExpirationTimestamp(body) {\n    if (typeof body.expires_on === \"number\") {\n        return body.expires_on * 1000;\n    }\n    if (typeof body.expires_on === \"string\") {\n        const asNumber = +body.expires_on;\n        if (!isNaN(asNumber)) {\n            return asNumber * 1000;\n        }\n        const asDate = Date.parse(body.expires_on);\n        if (!isNaN(asDate)) {\n            return asDate;\n        }\n    }\n    if (typeof body.expires_in === \"number\") {\n        return Date.now() + body.expires_in * 1000;\n    }\n    throw new Error(`Failed to parse token expiration from body. expires_in=\"${body.expires_in}\", expires_on=\"${body.expires_on}\"`);\n}\n/**\n * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.\n * @param body - A parsed response body from the authentication endpoint.\n */\nexport function parseRefreshTimestamp(body) {\n    if (body.refresh_on) {\n        if (typeof body.refresh_on === \"number\") {\n            return body.refresh_on * 1000;\n        }\n        if (typeof body.refresh_on === \"string\") {\n            const asNumber = +body.refresh_on;\n            if (!isNaN(asNumber)) {\n                return asNumber * 1000;\n            }\n            const asDate = Date.parse(body.refresh_on);\n            if (!isNaN(asDate)) {\n                return asDate;\n            }\n        }\n        throw new Error(`Failed to parse refresh_on from body. refresh_on=\"${body.refresh_on}\"`);\n    }\n    else {\n        return undefined;\n    }\n}\n//# sourceMappingURL=utils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors.js\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint.js\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nimport { logger } from \"../util/logging.js\";\nimport { parseExpirationTimestamp, parseRefreshTimestamp, } from \"../credentials/managedIdentityCredential/utils.js\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n    // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n    let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n    // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n    if (isNode) {\n        authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n    }\n    // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n    return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient {\n    constructor(options) {\n        var _a, _b;\n        const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n        const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix)\n            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n            : `${packageDetails}`;\n        const baseUri = getIdentityClientAuthorityHost(options);\n        if (!baseUri.startsWith(\"https:\")) {\n            throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n        }\n        super(Object.assign(Object.assign({ requestContentType: \"application/json; charset=utf-8\", retryOptions: {\n                maxRetries: 3,\n            } }, options), { userAgentOptions: {\n                userAgentPrefix,\n            }, baseUri }));\n        this.allowInsecureConnection = false;\n        this.authorityHost = baseUri;\n        this.abortControllers = new Map();\n        this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;\n        // used for WorkloadIdentity\n        this.tokenCredentialOptions = Object.assign({}, options);\n        // used for ManagedIdentity\n        if (options === null || options === void 0 ? void 0 : options.allowInsecureConnection) {\n            this.allowInsecureConnection = options.allowInsecureConnection;\n        }\n    }\n    async sendTokenRequest(request) {\n        logger.info(`IdentityClient: sending token request to [${request.url}]`);\n        const response = await this.sendRequest(request);\n        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n            const parsedBody = JSON.parse(response.bodyAsText);\n            if (!parsedBody.access_token) {\n                return null;\n            }\n            this.logIdentifiers(response);\n            const token = {\n                accessToken: {\n                    token: parsedBody.access_token,\n                    expiresOnTimestamp: parseExpirationTimestamp(parsedBody),\n                    refreshAfterTimestamp: parseRefreshTimestamp(parsedBody),\n                    tokenType: \"Bearer\",\n                },\n                refreshToken: parsedBody.refresh_token,\n            };\n            logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n            return token;\n        }\n        else {\n            const error = new AuthenticationError(response.status, response.bodyAsText);\n            logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n            throw error;\n        }\n    }\n    async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {\n        if (refreshToken === undefined) {\n            return null;\n        }\n        logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n        const refreshParams = {\n            grant_type: \"refresh_token\",\n            client_id: clientId,\n            refresh_token: refreshToken,\n            scope: scopes,\n        };\n        if (clientSecret !== undefined) {\n            refreshParams.client_secret = clientSecret;\n        }\n        const query = new URLSearchParams(refreshParams);\n        return tracingClient.withSpan(\"IdentityClient.refreshAccessToken\", options, async (updatedOptions) => {\n            try {\n                const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n                const request = createPipelineRequest({\n                    url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n                    method: \"POST\",\n                    body: query.toString(),\n                    abortSignal: options.abortSignal,\n                    headers: createHttpHeaders({\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/x-www-form-urlencoded\",\n                    }),\n                    tracingOptions: updatedOptions.tracingOptions,\n                });\n                const response = await this.sendTokenRequest(request);\n                logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n                return response;\n            }\n            catch (err) {\n                if (err.name === AuthenticationErrorName &&\n                    err.errorResponse.error === \"interaction_required\") {\n                    // It's likely that the refresh token has expired, so\n                    // return null so that the credential implementation will\n                    // initiate the authentication flow again.\n                    logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n                    return null;\n                }\n                else {\n                    logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n                    throw err;\n                }\n            }\n        });\n    }\n    // Here is a custom layer that allows us to abort requests that go through MSAL,\n    // since MSAL doesn't allow us to pass options all the way through.\n    generateAbortSignal(correlationId) {\n        const controller = new AbortController();\n        const controllers = this.abortControllers.get(correlationId) || [];\n        controllers.push(controller);\n        this.abortControllers.set(correlationId, controllers);\n        const existingOnAbort = controller.signal.onabort;\n        controller.signal.onabort = (...params) => {\n            this.abortControllers.set(correlationId, undefined);\n            if (existingOnAbort) {\n                existingOnAbort.apply(controller.signal, params);\n            }\n        };\n        return controller.signal;\n    }\n    abortRequests(correlationId) {\n        const key = correlationId || noCorrelationId;\n        const controllers = [\n            ...(this.abortControllers.get(key) || []),\n            // MSAL passes no correlation ID to the get requests...\n            ...(this.abortControllers.get(noCorrelationId) || []),\n        ];\n        if (!controllers.length) {\n            return;\n        }\n        for (const controller of controllers) {\n            controller.abort();\n        }\n        this.abortControllers.set(key, undefined);\n    }\n    getCorrelationId(options) {\n        var _a;\n        const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map((part) => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n    }\n    // The MSAL network module methods follow\n    async sendGetRequestAsync(url, options) {\n        const request = createPipelineRequest({\n            url,\n            method: \"GET\",\n            body: options === null || options === void 0 ? void 0 : options.body,\n            allowInsecureConnection: this.allowInsecureConnection,\n            headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n            abortSignal: this.generateAbortSignal(noCorrelationId),\n        });\n        const response = await this.sendRequest(request);\n        this.logIdentifiers(response);\n        return {\n            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n            headers: response.headers.toJSON(),\n            status: response.status,\n        };\n    }\n    async sendPostRequestAsync(url, options) {\n        const request = createPipelineRequest({\n            url,\n            method: \"POST\",\n            body: options === null || options === void 0 ? void 0 : options.body,\n            headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n            allowInsecureConnection: this.allowInsecureConnection,\n            // MSAL doesn't send the correlation ID on the get requests.\n            abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),\n        });\n        const response = await this.sendRequest(request);\n        this.logIdentifiers(response);\n        return {\n            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n            headers: response.headers.toJSON(),\n            status: response.status,\n        };\n    }\n    /**\n     *\n     * @internal\n     */\n    getTokenCredentialOptions() {\n        return this.tokenCredentialOptions;\n    }\n    /**\n     * If allowLoggingAccountIdentifiers was set on the constructor options\n     * we try to log the account identifiers by parsing the received access token.\n     *\n     * The account identifiers we try to log are:\n     * - `appid`: The application or Client Identifier.\n     * - `upn`: User Principal Name.\n     *   - It might not be available in some authentication scenarios.\n     *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n     * - `tid`: Tenant Identifier.\n     * - `oid`: Object Identifier of the authenticated user.\n     */\n    logIdentifiers(response) {\n        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n            return;\n        }\n        const unavailableUpn = \"No User Principal Name available\";\n        try {\n            const parsed = response.parsedBody || JSON.parse(response.bodyAsText);\n            const accessToken = parsed.access_token;\n            if (!accessToken) {\n                // Without an access token allowLoggingAccountIdentifiers isn't useful.\n                return;\n            }\n            const base64Metadata = accessToken.split(\".\")[1];\n            const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, \"base64\").toString(\"utf8\"));\n            logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);\n        }\n        catch (e) {\n            logger.warning(\"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\", e.message);\n        }\n    }\n}\n//# sourceMappingURL=identityClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { IdentityClient } from \"../client/identityClient.js\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nconst logger = credentialLogger(\"ClientSecretCredential\");\n// This credential is exported on browser bundles for development purposes.\n// For this credential to work in browsers, browsers would need to have security features disabled.\n// Please do not disable your browser security features.\n/**\n * Enables authentication to Microsoft Entra ID using a client secret\n * that was generated for an App Registration.  More information on how\n * to configure a client secret can be found here:\n *\n * https://learn.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application\n *\n */\nexport class ClientSecretCredential {\n    /**\n     * Creates an instance of the ClientSecretCredential with the details\n     * needed to authenticate against Microsoft Entra ID with a client\n     * secret.\n     *\n     * @param tenantId - The Microsoft Entra tenant (directory) ID.\n     * @param clientId - The client (application) ID of an App Registration in the tenant.\n     * @param clientSecret - A client secret that was generated for the App Registration.\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(tenantId, clientId, clientSecret, options) {\n        this.identityClient = new IdentityClient(options);\n        this.tenantId = tenantId;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if\n     * successful.  If authentication cannot be performed at this time, this method may\n     * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n     * containing failure details will be thrown.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            const query = new URLSearchParams({\n                response_type: \"token\",\n                grant_type: \"client_credentials\",\n                client_id: this.clientId,\n                client_secret: this.clientSecret,\n                scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n            });\n            try {\n                const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n                const request = createPipelineRequest({\n                    url: `${this.identityClient.authorityHost}/${tenantId}/${urlSuffix}`,\n                    method: \"POST\",\n                    body: query.toString(),\n                    headers: createHttpHeaders({\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/x-www-form-urlencoded\",\n                    }),\n                    abortSignal: options && options.abortSignal,\n                    tracingOptions: newOptions === null || newOptions === void 0 ? void 0 : newOptions.tracingOptions,\n                });\n                const tokenResponse = await this.identityClient.sendTokenRequest(request);\n                logger.getToken.info(formatSuccess(scopes));\n                return (tokenResponse && tokenResponse.accessToken) || null;\n            }\n            catch (err) {\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n            }\n        });\n    }\n}\n//# sourceMappingURL=clientSecretCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"EnvironmentCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"EnvironmentCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using client secret\n * details configured in environment variables\n */\nexport class EnvironmentCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=environmentCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ClientCertificateCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ClientCertificateCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a PEM-encoded\n * certificate that is assigned to an App Registration.\n */\nexport class ClientCertificateCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=clientCertificateCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ClientAssertionCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ClientAssertionCredential\");\n/**\n * Authenticates a service principal with a JWT assertion.\n */\nexport class ClientAssertionCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=clientAssertionCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzureCliCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzureCliCredential\");\n/**\n * This credential will use the currently logged-in user login information\n * via the Azure CLI ('az') commandline tool.\n */\nexport class AzureCliCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azureCliCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzureDeveloperCliCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzureDeveloperCliCredential\");\n/**\n * This credential will use the currently logged-in user login information\n * via the Azure Developer CLI ('azd') commandline tool.\n */\nexport class AzureDeveloperCliCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azureDeveloperCliCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { formatError } from \"./logging.js\";\n/**\n * Ensures the scopes value is an array.\n * @internal\n */\nexport function ensureScopes(scopes) {\n    return Array.isArray(scopes) ? scopes : [scopes];\n}\n/**\n * Throws if the received scope is not valid.\n * @internal\n */\nexport function ensureValidScopeForDevTimeCreds(scope, logger) {\n    if (!scope.match(/^[0-9a-zA-Z-_.:/]+$/)) {\n        const error = new Error(\"Invalid scope was specified by the user or calling client\");\n        logger.getToken.info(formatError(scope, error));\n        throw error;\n    }\n}\n/**\n * Returns the resource out of a scope.\n * @internal\n */\nexport function getScopeResource(scope) {\n    return scope.replace(/\\/.default$/, \"\");\n}\n//# sourceMappingURL=scopeUtils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as msalBrowser from \"@azure/msal-browser\";\nimport { defaultLoggerCallback, ensureValidMsalToken, getAuthority, getKnownAuthorities, getMSALLogLevel, handleMsalError, msalToPublic, publicToMsal, } from \"../utils.js\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../../errors.js\";\nimport { getLogLevel } from \"@azure/logger\";\nimport { formatSuccess } from \"../../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, resolveTenantId, } from \"../../util/tenantIdUtils.js\";\nimport { DefaultTenantId } from \"../../constants.js\";\n// We keep a copy of the redirect hash.\n// Check if self and location object is defined.\nconst isLocationDefined = typeof self !== \"undefined\" && self.location !== undefined;\n/**\n * Generates a MSAL configuration that generally works for browsers\n * @internal\n */\nfunction generateMsalBrowserConfiguration(options) {\n    var _a;\n    const tenantId = options.tenantId || DefaultTenantId;\n    const authority = getAuthority(tenantId, options.authorityHost);\n    return {\n        auth: {\n            clientId: options.clientId,\n            authority,\n            knownAuthorities: getKnownAuthorities(tenantId, authority, options.disableInstanceDiscovery),\n            // If the users picked redirect as their login style,\n            // but they didn't provide a redirectUri,\n            // we can try to use the current page we're in as a default value.\n            redirectUri: options.redirectUri || (isLocationDefined ? self.location.origin : undefined),\n        },\n        cache: {\n            cacheLocation: \"sessionStorage\",\n            storeAuthStateInCookie: true, // Set to true to improve the experience on IE11 and Edge.\n        },\n        system: {\n            loggerOptions: {\n                loggerCallback: defaultLoggerCallback(options.logger, \"Browser\"),\n                logLevel: getMSALLogLevel(getLogLevel()),\n                piiLoggingEnabled: (_a = options.loggingOptions) === null || _a === void 0 ? void 0 : _a.enableUnsafeSupportLogging,\n            },\n        },\n    };\n}\n// We keep a copy of the redirect hash.\nconst redirectHash = isLocationDefined ? self.location.hash : undefined;\n/**\n * Uses MSAL Browser 2.X for browser authentication,\n * which uses the [Auth Code Flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n * @internal\n */\nexport function createMsalBrowserClient(options) {\n    var _a;\n    const loginStyle = options.loginStyle;\n    if (!options.clientId) {\n        throw new CredentialUnavailableError(\"A client ID is required in browsers\");\n    }\n    const clientId = options.clientId;\n    const logger = options.logger;\n    const tenantId = resolveTenantId(logger, options.tenantId, options.clientId);\n    const additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds((_a = options === null || options === void 0 ? void 0 : options.tokenCredentialOptions) === null || _a === void 0 ? void 0 : _a.additionallyAllowedTenants);\n    const authorityHost = options.authorityHost;\n    const msalConfig = generateMsalBrowserConfiguration(options);\n    const disableAutomaticAuthentication = options.disableAutomaticAuthentication;\n    const loginHint = options.loginHint;\n    let account;\n    if (options.authenticationRecord) {\n        account = Object.assign(Object.assign({}, options.authenticationRecord), { tenantId });\n    }\n    // This variable should only be used through calling `getApp` function\n    let app;\n    /**\n     * Return the MSAL account if not set yet\n     * @returns MSAL application\n     */\n    async function getApp() {\n        if (!app) {\n            // Prepare the MSAL application\n            app = await msalBrowser.PublicClientApplication.createPublicClientApplication(msalConfig);\n            // setting the account right after the app is created.\n            if (account) {\n                app.setActiveAccount(publicToMsal(account));\n            }\n        }\n        return app;\n    }\n    /**\n     * Loads the account based on the result of the authentication.\n     * If no result was received, tries to load the account from the cache.\n     * @param result - Result object received from MSAL.\n     */\n    async function handleBrowserResult(result) {\n        try {\n            const msalApp = await getApp();\n            if (result && result.account) {\n                logger.info(`MSAL Browser V2 authentication successful.`);\n                msalApp.setActiveAccount(result.account);\n                return msalToPublic(clientId, result.account);\n            }\n            // If by this point we happen to have an active account, we should stop trying to parse this.\n            const activeAccount = msalApp.getActiveAccount();\n            if (activeAccount) {\n                return msalToPublic(clientId, activeAccount);\n            }\n            // If we don't have an active account, we try to activate it from all the already loaded accounts.\n            const allAccounts = app.getAllAccounts();\n            if (allAccounts.length > 1) {\n                // If there's more than one account in memory, we force the user to authenticate again.\n                // At this point we can't identify which account should this credential work with,\n                // since at this point the user won't have provided enough information.\n                // We log a message in case that helps.\n                logger.info(`More than one account was found authenticated for this Client ID and Tenant ID.\n  However, no \"authenticationRecord\" has been provided for this credential,\n  therefore we're unable to pick between these accounts.\n  A new login attempt will be requested, to ensure the correct account is picked.\n  To work with multiple accounts for the same Client ID and Tenant ID, please provide an \"authenticationRecord\" when initializing \"InteractiveBrowserCredential\".`);\n                // To safely trigger a new login, we're also ensuring the local cache is cleared up for this MSAL object.\n                // However, we want to avoid kicking the user out of their authentication on the Azure side.\n                // We do this by calling to logout while specifying a `onRedirectNavigate` that returns false.\n                await msalApp.logout({\n                    onRedirectNavigate: () => false,\n                });\n                return;\n            }\n            // If there's only one account for this MSAL object, we can safely activate it.\n            if (allAccounts.length === 1) {\n                const msalAccount = allAccounts[0];\n                msalApp.setActiveAccount(msalAccount);\n                return msalToPublic(clientId, msalAccount);\n            }\n            logger.info(`No accounts were found through MSAL.`);\n        }\n        catch (e) {\n            logger.info(`Failed to acquire token through MSAL. ${e.message}`);\n        }\n        return;\n    }\n    /**\n     * Handles the MSAL authentication result.\n     * If the result has an account, we update the local account reference.\n     * If the token received is invalid, an error will be thrown depending on what's missing.\n     */\n    function handleResult(scopes, result, getTokenOptions) {\n        var _a;\n        if (result === null || result === void 0 ? void 0 : result.account) {\n            account = msalToPublic(clientId, result.account);\n        }\n        ensureValidMsalToken(scopes, result, getTokenOptions);\n        logger.getToken.info(formatSuccess(scopes));\n        return {\n            token: result.accessToken,\n            expiresOnTimestamp: result.expiresOn.getTime(),\n            refreshAfterTimestamp: (_a = result.refreshOn) === null || _a === void 0 ? void 0 : _a.getTime(),\n            tokenType: \"Bearer\",\n        };\n    }\n    /**\n     * Uses MSAL to handle the redirect.\n     */\n    async function handleRedirect() {\n        const msalApp = await getApp();\n        return handleBrowserResult((await msalApp.handleRedirectPromise(redirectHash)) || undefined);\n    }\n    /**\n     * Uses MSAL to retrieve the active account.\n     */\n    async function getActiveAccount() {\n        const msalApp = await getApp();\n        const activeAccount = msalApp.getActiveAccount();\n        if (!activeAccount) {\n            return;\n        }\n        return msalToPublic(clientId, activeAccount);\n    }\n    /**\n     * Uses MSAL to trigger a redirect or a popup login.\n     */\n    async function login(scopes = []) {\n        const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n        const loginRequest = {\n            scopes: arrayScopes,\n            loginHint: loginHint,\n        };\n        const msalApp = await getApp();\n        switch (loginStyle) {\n            case \"redirect\": {\n                await app.loginRedirect(loginRequest);\n                return;\n            }\n            case \"popup\":\n                return handleBrowserResult(await msalApp.loginPopup(loginRequest));\n        }\n    }\n    /**\n     * Tries to retrieve the token silently using MSAL.\n     */\n    async function getTokenSilent(scopes, getTokenOptions) {\n        const activeAccount = await getActiveAccount();\n        if (!activeAccount) {\n            throw new AuthenticationRequiredError({\n                scopes,\n                getTokenOptions,\n                message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\",\n            });\n        }\n        const parameters = {\n            authority: (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.authority) || msalConfig.auth.authority,\n            correlationId: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.correlationId,\n            claims: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.claims,\n            account: publicToMsal(activeAccount),\n            forceRefresh: false,\n            scopes,\n        };\n        try {\n            logger.info(\"Attempting to acquire token silently\");\n            const msalApp = await getApp();\n            const response = await msalApp.acquireTokenSilent(parameters);\n            return handleResult(scopes, response);\n        }\n        catch (err) {\n            throw handleMsalError(scopes, err, options);\n        }\n    }\n    /**\n     * Attempts to retrieve the token in the browser through interactive methods.\n     */\n    async function getTokenInteractive(scopes, getTokenOptions) {\n        const activeAccount = await getActiveAccount();\n        if (!activeAccount) {\n            throw new AuthenticationRequiredError({\n                scopes,\n                getTokenOptions,\n                message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\",\n            });\n        }\n        const parameters = {\n            authority: (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.authority) || msalConfig.auth.authority,\n            correlationId: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.correlationId,\n            claims: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.claims,\n            account: publicToMsal(activeAccount),\n            loginHint: loginHint,\n            scopes,\n        };\n        const msalApp = await getApp();\n        switch (loginStyle) {\n            case \"redirect\":\n                // This will go out of the page.\n                // Once the InteractiveBrowserCredential is initialized again,\n                // we'll load the MSAL account in the constructor.\n                await msalApp.acquireTokenRedirect(parameters);\n                return { token: \"\", expiresOnTimestamp: 0, tokenType: \"Bearer\" };\n            case \"popup\":\n                return handleResult(scopes, await app.acquireTokenPopup(parameters));\n        }\n    }\n    /**\n     * Attempts to get token through the silent flow.\n     * If failed, get token through interactive method with `doGetToken` method.\n     */\n    async function getToken(scopes, getTokenOptions = {}) {\n        const getTokenTenantId = processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds) ||\n            tenantId;\n        if (!getTokenOptions.authority) {\n            getTokenOptions.authority = getAuthority(getTokenTenantId, authorityHost);\n        }\n        // We ensure that redirection is handled at this point.\n        await handleRedirect();\n        if (!(await getActiveAccount()) && !disableAutomaticAuthentication) {\n            await login(scopes);\n        }\n        // Attempts to get the token silently; else, falls back to interactive method.\n        try {\n            return await getTokenSilent(scopes, getTokenOptions);\n        }\n        catch (err) {\n            if (err.name !== \"AuthenticationRequiredError\") {\n                throw err;\n            }\n            if (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.disableAutomaticAuthentication) {\n                throw new AuthenticationRequiredError({\n                    scopes,\n                    getTokenOptions,\n                    message: \"Automatic authentication has been disabled. You may call the authenticate() method.\",\n                });\n            }\n            logger.info(`Silent authentication failed, falling back to interactive method ${loginStyle}`);\n            return getTokenInteractive(scopes, getTokenOptions);\n        }\n    }\n    return {\n        getActiveAccount,\n        getToken,\n    };\n}\n//# sourceMappingURL=msalBrowserCommon.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { ensureScopes } from \"../util/scopeUtils.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nimport { createMsalBrowserClient } from \"../msal/browserFlows/msalBrowserCommon.js\";\nconst logger = credentialLogger(\"InteractiveBrowserCredential\");\n/**\n * Enables authentication to Microsoft Entra ID inside of the web browser\n * using the interactive login flow.\n */\nexport class InteractiveBrowserCredential {\n    /**\n     * Creates an instance of the InteractiveBrowserCredential with the\n     * details needed to authenticate against Microsoft Entra ID with\n     * a user identity.\n     *\n     * This credential uses the [Authorization Code Flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n     * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.\n     * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.\n     *\n     * It's recommended that the Microsoft Entra Applications used are configured to authenticate using Single Page Applications.\n     * More information here: [link](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-spa-app-registration#redirect-uri-msaljs-20-with-auth-code-flow).\n     *\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(options) {\n        if (!(options === null || options === void 0 ? void 0 : options.clientId)) {\n            const error = new Error(\"The parameter `clientId` cannot be left undefined for the `InteractiveBrowserCredential`\");\n            logger.info(formatError(\"\", error));\n            throw error;\n        }\n        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);\n        const browserOptions = options;\n        const loginStyle = browserOptions.loginStyle || \"popup\";\n        const loginStyles = [\"redirect\", \"popup\"];\n        if (loginStyles.indexOf(loginStyle) === -1) {\n            const error = new Error(`Invalid loginStyle: ${browserOptions.loginStyle}. Should be any of the following: ${loginStyles.join(\", \")}.`);\n            logger.info(formatError(\"\", error));\n            throw error;\n        }\n        const msalOptions = Object.assign(Object.assign({}, options), { tokenCredentialOptions: options, logger, loginStyle: loginStyle, redirectUri: typeof options.redirectUri === \"function\" ? options.redirectUri() : options.redirectUri });\n        this.msalClient = createMsalBrowserClient(msalOptions);\n        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if successful.\n     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.\n     *\n     * If the user provided the option `disableAutomaticAuthentication`,\n     * once the token can't be retrieved silently,\n     * this method won't attempt to request user interaction to retrieve the token.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            newOptions.tenantId = tenantId;\n            const arrayScopes = ensureScopes(scopes);\n            return this.msalClient.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));\n        });\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if successful.\n     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.\n     *\n     * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                  TokenCredential implementation might make.\n     */\n    async authenticate(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {\n            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n            await this.msalClient.getToken(arrayScopes, newOptions);\n            return this.msalClient.getActiveAccount();\n        });\n    }\n}\n//# sourceMappingURL=interactiveBrowserCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ManagedIdentityCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ManagedIdentityCredential\");\nexport class ManagedIdentityCredential {\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    async getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=index-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"DeviceCodeCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"DeviceCodeCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a device code\n * that the user can enter into https://microsoft.com/devicelogin.\n */\nexport class DeviceCodeCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=deviceCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzurePipelinesCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzurePipelinesCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a PEM-encoded\n * certificate that is assigned to an App Registration.\n */\nexport class AzurePipelinesCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azurePipelinesCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AuthorizationCodeCredential is not supported in the browser. InteractiveBrowserCredential is more appropriate for this use case.\");\nconst logger = credentialLogger(\"AuthorizationCodeCredential\");\nexport class AuthorizationCodeCredential {\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=authorizationCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzurePowerShellCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzurePowerShellCredential\");\n/**\n * This credential will use the currently-logged-in user's login information via the Azure Power Shell command line tool.\n */\nexport class AzurePowerShellCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azurePowerShellCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { checkTenantId, processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { credentialLogger, formatSuccess } from \"../util/logging.js\";\nimport { IdentityClient } from \"../client/identityClient.js\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nconst logger = credentialLogger(\"UsernamePasswordCredential\");\n/**\n * Enables authentication to Microsoft Entra ID with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n *\n * @deprecated UsernamePasswordCredential is deprecated. Use a more secure credential. See https://aka.ms/azsdk/identity/mfa for details.\n */\nexport class UsernamePasswordCredential {\n    /**\n     * Creates an instance of the UsernamePasswordCredential with the details\n     * needed to authenticate against Microsoft Entra ID with a username\n     * and password.\n     *\n     * @param tenantIdOrName - The Microsoft Entra tenant (directory) ID or name.\n     * @param clientId - The client (application) ID of an App Registration in the tenant.\n     * @param username - The user account's e-mail address (user name).\n     * @param password - The user account's account password\n     * @param options - Options for configuring the client which makes the authentication request.\n     *\n     */\n    constructor(tenantIdOrName, clientId, username, password, options) {\n        checkTenantId(logger, tenantIdOrName);\n        this.identityClient = new IdentityClient(options);\n        this.tenantId = tenantIdOrName;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);\n        this.clientId = clientId;\n        this.username = username;\n        this.password = password;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if\n     * successful.  If authentication cannot be performed at this time, this method may\n     * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n     * containing failure details will be thrown.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(\"UsernamePasswordCredential.getToken\", options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            newOptions.tenantId = tenantId;\n            const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);\n            const params = new URLSearchParams({\n                response_type: \"token\",\n                grant_type: \"password\",\n                client_id: this.clientId,\n                username: this.username,\n                password: this.password,\n                scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n            });\n            const webResource = createPipelineRequest({\n                url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,\n                method: \"POST\",\n                body: params.toString(),\n                headers: createHttpHeaders({\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                }),\n                abortSignal: options && options.abortSignal,\n                tracingOptions: newOptions.tracingOptions,\n            });\n            const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n            logger.getToken.info(formatSuccess(scopes));\n            return (tokenResponse && tokenResponse.accessToken) || null;\n        });\n    }\n}\n//# sourceMappingURL=usernamePasswordCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"VisualStudioCodeCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"VisualStudioCodeCredential\");\nexport const vsCodeCredentialControl = {\n    set vsCodeCredentialFinder(_finder) {\n        throw new Error(\"Attempted to register a VisualStudioCodeCredential provider plugin in the browser. This environment is not supported by VisualStudioCodeCredential.\");\n    },\n};\n/**\n * Connects to Azure using the credential provided by the VSCode extension 'Azure Account'.\n *\n * @deprecated This credential is deprecated because the VS Code Azure Account extension on which this credential\n * relies has been deprecated. Users should use other dev-time credentials, such as {@link AzureCliCredential},\n * {@link AzureDeveloperCliCredential}, or {@link AzurePowerShellCredential} for their\n * local development needs. See Azure account extension deprecation notice [here](https://github.com/microsoft/vscode-azure-account/issues/964).\n */\nexport class VisualStudioCodeCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=visualStudioCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst credentialName = \"OnBehalfOfCredential\";\nconst BrowserNotSupportedError = new Error(`${credentialName}: Not supported in the browser.`);\nconst logger = credentialLogger(credentialName);\n/**\n * Enables authentication to Microsoft Entra ID using the [On Behalf Of flow](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow).\n */\nexport class OnBehalfOfCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=onBehalfOfCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"WorkloadIdentityCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"WorkloadIdentityCredential\");\n/**\n * WorkloadIdentityCredential supports Microsoft Entra Workload ID authentication on Kubernetes.\n * Refer to <a href=\"https://learn.microsoft.com/azure/aks/workload-identity-overview\">Microsoft Entra Workload ID</a>\n * for more information.\n */\nexport class WorkloadIdentityCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    /**\n     * Only available in Node.js\n     */\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=workloadIdentityCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { bearerTokenAuthenticationPolicy, createEmptyPipeline, createPipelineRequest, } from \"@azure/core-rest-pipeline\";\n/**\n * Returns a callback that provides a bearer token.\n * For example, the bearer token can be used to authenticate a request as follows:\n * ```ts snippet:token_provider_example\n * import { DefaultAzureCredential, getBearerTokenProvider } from \"@azure/identity\";\n * import { createPipelineRequest } from \"@azure/core-rest-pipeline\";\n *\n * const credential = new DefaultAzureCredential();\n * const scope = \"https://cognitiveservices.azure.com/.default\";\n * const getAccessToken = getBearerTokenProvider(credential, scope);\n * const token = await getAccessToken();\n *\n * // usage\n * const request = createPipelineRequest({ url: \"https://example.com\" });\n * request.headers.set(\"Authorization\", `Bearer ${token}`);\n * ```\n *\n * @param credential - The credential used to authenticate the request.\n * @param scopes - The scopes required for the bearer token.\n * @param options - Options to configure the token provider.\n * @returns a callback that provides a bearer token.\n */\nexport function getBearerTokenProvider(credential, scopes, options) {\n    const { abortSignal, tracingOptions } = options || {};\n    const pipeline = createEmptyPipeline();\n    pipeline.addPolicy(bearerTokenAuthenticationPolicy({ credential, scopes }));\n    async function getRefreshedToken() {\n        var _a;\n        // Create a pipeline with just the bearer token policy\n        // and run a dummy request through it to get the token\n        const res = await pipeline.sendRequest({\n            sendRequest: (request) => Promise.resolve({\n                request,\n                status: 200,\n                headers: request.headers,\n            }),\n        }, createPipelineRequest({\n            url: \"https://example.com\",\n            abortSignal,\n            tracingOptions,\n        }));\n        const accessToken = (_a = res.headers.get(\"authorization\")) === null || _a === void 0 ? void 0 : _a.split(\" \")[1];\n        if (!accessToken) {\n            throw new Error(\"Failed to get access token\");\n        }\n        return accessToken;\n    }\n    return getRefreshedToken;\n}\n//# sourceMappingURL=tokenProvider.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport * from \"./plugins/consumer.js\";\nimport { DefaultAzureCredential } from \"./credentials/defaultAzureCredential.js\";\nexport { AuthenticationError, AggregateAuthenticationError, AuthenticationErrorName, AggregateAuthenticationErrorName, CredentialUnavailableError, CredentialUnavailableErrorName, AuthenticationRequiredError, } from \"./errors.js\";\nexport { serializeAuthenticationRecord, deserializeAuthenticationRecord } from \"./msal/utils.js\";\nexport { ChainedTokenCredential } from \"./credentials/chainedTokenCredential.js\";\nexport { ClientSecretCredential } from \"./credentials/clientSecretCredential.js\";\nexport { DefaultAzureCredential } from \"./credentials/defaultAzureCredential.js\";\nexport { EnvironmentCredential } from \"./credentials/environmentCredential.js\";\nexport { ClientCertificateCredential } from \"./credentials/clientCertificateCredential.js\";\nexport { ClientAssertionCredential } from \"./credentials/clientAssertionCredential.js\";\nexport { AzureCliCredential } from \"./credentials/azureCliCredential.js\";\nexport { AzureDeveloperCliCredential } from \"./credentials/azureDeveloperCliCredential.js\";\nexport { InteractiveBrowserCredential } from \"./credentials/interactiveBrowserCredential.js\";\nexport { ManagedIdentityCredential } from \"./credentials/managedIdentityCredential/index.js\";\nexport { DeviceCodeCredential } from \"./credentials/deviceCodeCredential.js\";\nexport { AzurePipelinesCredential as AzurePipelinesCredential } from \"./credentials/azurePipelinesCredential.js\";\nexport { AuthorizationCodeCredential } from \"./credentials/authorizationCodeCredential.js\";\nexport { AzurePowerShellCredential } from \"./credentials/azurePowerShellCredential.js\";\nexport { UsernamePasswordCredential } from \"./credentials/usernamePasswordCredential.js\";\nexport { VisualStudioCodeCredential } from \"./credentials/visualStudioCodeCredential.js\";\nexport { OnBehalfOfCredential } from \"./credentials/onBehalfOfCredential.js\";\nexport { WorkloadIdentityCredential } from \"./credentials/workloadIdentityCredential.js\";\nexport { logger } from \"./util/logging.js\";\nexport { AzureAuthorityHosts } from \"./constants.js\";\n/**\n * Returns a new instance of the {@link DefaultAzureCredential}.\n */\nexport function getDefaultAzureCredential() {\n    return new DefaultAzureCredential();\n}\nexport { getBearerTokenProvider } from \"./tokenProvider.js\";\n//# sourceMappingURL=index.js.map"],"names":["log","args","firstArg","debugEnvVariable","process","enabledString","enabledNamespaces","skippedNamespaces","debuggers","enable","debugObj","namespace","createDebugger","enabled","disable","namespaces","wildcard","namespaceList","ns","instance","skipped","enabledNamespace","result","newDebugger","debug","destroy","extend","index","registeredLoggers","logLevelFromEnv","azureLogLevel","AzureLogger","AZURE_LOG_LEVELS","isAzureLogLevel","setLogLevel","level","logger","shouldEnable","levelMap","createClientLogger","clientRootLogger","patchLogMethod","createLogger","parent","child","logLevel","processEnvVars","supportedEnvVars","acc","envVariable","logEnvVars","credentialName","assigned","scope","error","message","credentialLoggerInstance","title","fullTitle","info","warning","verbose","credentialLogger","credLogger","isErrorResponse","errorResponse","CredentialUnavailableErrorName","options","AuthenticationErrorName","AuthenticationError","statusCode","errorBody","convertOAuthErrorResponseToErrorResponse","oauthErrorResponse","AggregateAuthenticationErrorName","AggregateAuthenticationError","errors","errorMessage","errorDetail","SDK_VERSION","AzureAuthorityHosts","CACHE_CAE_SUFFIX","CACHE_NON_CAE_SUFFIX","DEFAULT_TOKEN_CACHE_NAME","knownContextKeys","createTracingContext","context","TracingContextImpl","initialContext","key","value","newContext","createDefaultTracingSpan","createDefaultInstrumenter","_name","spanOptions","_context","callback","callbackArgs","useInstrumenter","instrumenter","getInstrumenter","createTracingClient","packageName","packageVersion","startSpan","name","operationOptions","_a","startSpanResult","tracingContext","span","updatedOptions","withSpan","withContext","err","parseTraceparentHeader","traceparentHeader","createRequestHeaders","ChainedTokenCredential","sources","scopes","token","successfulCredential","i","BrowserNotSupportedError","_tokenCredentialOptions","buildPromise","cleanupBeforeAbort","abortSignal","abortErrorMsg","resolve","reject","rejectOnAbort","removeListeners","onAbort","x","getRandomIntegerInclusive","min","max","StandardAbortMessage","delay","timeInMs","calculateRetryDelay","retryAttempt","config","exponentialDelay","clampedDelay","isObject","input","isError","e","hasName","hasMessage","getErrorMessage","stringified","bytes","format","uint8ArrayToUtf8String","uint8ArrayToBase64","uint8ArrayToBase64Url","uint8ArrayToHexString","utf8StringToUint8Array","base64ToUint8Array","base64UrlToUint8Array","hexStringToUint8Array","base64String","hexDigits","highNibble","lowNibble","subtleCrypto","getCrypto","computeSha256Hmac","stringToSign","encoding","crypto","keyBytes","stringToSignBytes","cryptoKey","signature","computeSha256Hash","content","contentBytes","digest","generateUUID","uuid","randomNumber","randomUUID","uuidFunction","_b","_c","_d","isBrowser","isWebWorker","isDeno","isBun","isNodeRuntime","isReactNative","LatestAuthenticationRecordVersion","msalToken","getTokenOptions","getAuthorityHost","authorityHost","tenantId","host","disableInstanceDiscovery","platform","containsPii","msalError","account","clientId","serializeAuthenticationRecord","record","deserializeAuthenticationRecord","serializedRecord","parsed","ValidPhaseNames","HttpPipeline","policies","policy","removedPolicies","policyDescriptor","httpClient","request","next","req","policyMap","createPhase","serializePhase","noPhase","deserializePhase","retryPhase","signPhase","orderedPhases","getPhase","phase","descriptor","policyName","node","afterPolicyName","afterNode","beforePolicyName","beforeNode","walkPhase","dependant","walkPhases","iteration","initialResultLength","RedactedString","defaultAllowedHeaderNames","defaultAllowedQueryParameters","Sanitizer","allowedHeaderNames","allowedQueryParameters","n","p","obj","seen","url","sanitized","k","logPolicyName","logPolicy","sanitizer","response","redirectPolicyName","allowedRedirect","redirectPolicy","maxRetries","handleRedirect","currentRetries","status","headers","locationHeader","res","getHeaderName","getBrowserInfo","userAgent","browserRegexes","browser","match","getBrandVersionString","brands","brandOrder","brand","foundBrand","b","setPlatformSpecificData","map","localNavigator","osPlatform","entropyValues","getUserAgentString","telemetryInfo","parts","getUserAgentHeaderName","getUserAgentValue","prefix","runtimeInfo","defaultAgent","UserAgentHeaderName","userAgentPolicyName","userAgentPolicy","userAgentValue","unimplementedMethods","rawContent","hasRawContent","getRawContent","blob","createFileFromStream","stream","createFile","isWebReadableStream","isReadableStream","isBlob","drain","toBlobPart","source","concat","generateBoundary","encodeHeaders","getLength","getTotalLength","total","partLength","buildRequestBody","boundary","part","contentLength","multipartPolicyName","maxBoundaryLength","validBoundaryCharacters","assertValidBoundary","multipartPolicy","contentTypeHeader","parsedHeader","contentType","parsedBoundary","decompressResponsePolicyName","decompressResponsePolicy","delayInMs","timer","onAborted","parseHeaderValueAsNumber","headerName","valueAsNum","RetryAfterHeader","AllRetryAfterHeaders","getRetryAfterInMs","header","retryAfterValue","retryAfterHeader","diff","isThrottlingRetryResponse","retryAfterInMs","DEFAULT_CLIENT_RETRY_INTERVAL","DEFAULT_CLIENT_MAX_RETRY_INTERVAL","retryInterval","maxRetryInterval","retryCount","responseError","matchedSystemError","isSystemError","ignoreSystemErrors","isExponential","isExponentialRetryResponse","ignoreExponentialResponse","retryPolicyLogger","retryPolicyName","strategies","retryRequest","strategiesLoop","strategy","strategyLogger","modifiers","errorToThrow","redirectTo","defaultRetryPolicyName","defaultRetryPolicy","normalizeName","headerIterator","entry","HttpHeadersImpl","rawHeaders","normalizedName","formDataPolicyName","formDataToFormDataMap","formData","formDataMap","formDataPolicy","wwwFormUrlEncode","prepareFormData","urlSearchParams","subValue","fieldName","values","fileName","proxyPolicyName","getDefaultProxySettings","proxyPolicy","resetCachedProxyAgents","setClientRequestIdPolicyName","setClientRequestIdPolicy","requestIdHeaderName","agentPolicyName","agentPolicy","agent","tlsPolicyName","tlsPolicy","tlsSettings","custom","errorSanitizer","RestError","isRestError","tracingPolicyName","tracingPolicy","userAgentPromise","tracingClient","tryCreateTracingClient","spanAttributes","tryCreateSpan","tryProcessResponse","tryProcessError","serviceRequestId","createPipelineFromOptions","pipeline","body","FetchHttpClient","makeRequest","getError","abortController","abortControllerCleanup","setupAbortSignal","buildFetchHeaders","streaming","requestBody","requestInit","buildPipelineResponse","httpResponse","buildPipelineHeaders","bodyStream","buildBodyStream","responseStream","abortListener","event","pipelineHeaders","responseHeaders","readableStream","loadedBytes","onProgress","onEnd","isTransformStreamSupported","chunk","controller","reader","done","reason","createFetchHttpClient","createDefaultHttpClient","PipelineRequestImpl","_e","_f","_g","exponentialRetryPolicyName","exponentialRetryPolicy","systemErrorRetryPolicyName","systemErrorRetryPolicy","throttlingRetryPolicyName","throttlingRetryPolicy","DEFAULT_CYCLER_OPTIONS","beginRefresh","getAccessToken","retryIntervalInMs","refreshTimeout","tryGetAccessToken","finalToken","credential","tokenCyclerOptions","refreshWorker","cycler","refresh","_token","tokenOptions","hasClaimChallenge","tenantIdChanged","bearerTokenAuthenticationPolicyName","trySendRequest","defaultAuthorizeRequest","accessToken","isChallengeResponse","authorizeRequestOnCaeChallenge","onChallengeOptions","caeClaims","challengeCallbacks","callbacks","shouldSendRequest","claims","getCaeChallengeClaims","parsedClaim","parseChallenges","challenges","challengeRegex","paramRegex","parsedChallenges","scheme","paramsString","params","paramMatch","auxiliaryAuthenticationHeaderPolicyName","AUTHORIZATION_AUXILIARY_HEADER","sendAuthorizeRequest","auxiliaryAuthenticationHeaderPolicy","credentials","tokenCyclerMap","tokenPromises","auxiliaryTokens","additionallyAllowedTenants","SerializerImpl","modelMappers","isXML","mapper","objectName","failValidation","constraintName","constraintValue","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","pattern","item","ar","object","payload","mapperType","required","nullable","serializeBasicTypes","serializeEnumType","serializeDateTypes","serializeByteArrayType","serializeBase64UrlType","serializeSequenceType","serializeDictionaryType","serializeCompositeType","responseBody","deserializeCompositeType","xmlCharKey","unixTimeToDate","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","createSerializer","trimEnd","str","ch","len","bufferToBase64Url","buffer","splitSerializeName","prop","classes","partialclass","subwords","dateToUnixTime","d","typeName","objectType","allowedValues","serializer","isXml","elementType","tempArray","serializedValue","xmlnsKey","valueType","tempDictionary","getXmlObjectValue","resolveAdditionalProperties","additionalProperties","modelMapper","resolveReferencedMapper","className","resolveModelProperties","modelProps","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","propertyMapper","propName","parentObject","paths","pathName","childObject","propertyObjectName","toSerialize","polymorphicDiscriminator","additionalPropertiesMapper","propNames","clientPropName","pn","xmlNamespace","isSpecialXmlProperty","propertyName","handledPropertyNames","serializedName","xmlName","xmlElementName","headerCollectionPrefix","dictionary","headerKey","wrapped","elementList","property","propertyInstance","steps","arrayInstance","v","isAdditionalProperty","responsePropName","element","getIndexDiscriminator","discriminators","discriminatorValue","typeNamesToCheck","currentName","indexDiscriminator","polymorphicPropertyName","discriminatorName","polymorphicMapper","getPolymorphicDiscriminatorSafely","MapperTypeNames","getOperationArgumentValueFromParameter","operationArguments","parameter","fallbackObject","parameterPath","parameterMapper","propertySearchResult","getPropertyFromParameterPath","useDefaultValue","propertyPath","propertyValue","parameterPathPart","originalRequestSymbol","hasOriginalRequest","getOperationRequestInfo","defaultJsonContentTypes","defaultXmlContentTypes","deserializationPolicyName","deserializationPolicy","jsonContentTypes","xmlContentTypes","parseXML","serializerOptions","deserializeResponseBody","getOperationResponseMap","parsedResponse","operationInfo","operationSpec","shouldDeserializeResponse","shouldDeserialize","parse","responseSpec","shouldReturnResponse","handleErrorResponse","valueToDeserialize","deserializeError","isOperationSpecEmpty","expectedStatusCodes","isSuccessByStatus","errorResponseSpec","initialErrorMessage","defaultBodyMapper","defaultHeadersMapper","parsedBody","deserializedError","elementName","internalError","defaultError","operationResponse","opts","text","contentComponents","component","msg","errCode","getStreamingResponseStatusCodes","getPathStringFromParameter","serializationPolicyName","serializationPolicy","stringifyXML","serializeHeaders","serializeRequestBody","headerParameter","headerValue","customHeaders","customHeaderName","bodyMapper","xmlNamespacePrefix","requestBodyParameterPathString","isStream","getXmlValueWithNamespace","prepareXMLRootList","formDataParameter","formDataParameterValue","formDataParameterPropertyName","xmlNamespaceKey","createClientPipeline","isPrimitiveBody","mapperTypeName","validateISODuration","validUuidRegex","handleNullableResponseAndWrappableBody","responseObject","combinedHeadersAndBody","flattenResponse","fullResponse","parsedHeaders","isNullable","expectedBodyTypeName","modelProperties","isPageableResponse","arrayResponse","cachedHttpClient","getCachedDefaultHttpClient","CollectionFormatToDelimiterMap","getRequestUrl","baseUri","urlReplacements","calculateUrlReplacements","isAbsolutePath","requestUrl","replaceAll","path","isAbsoluteUrl","appendPath","queryParams","sequenceParams","calculateQueryParameters","appendQueryParams","replacements","searchValue","replaceValue","urlParameter","urlParameterValue","parameterPathString","pathToAppend","parsedUrl","newPath","searchStart","search","queryParameter","queryParameterValue","delimiter","simpleParseQueryParams","queryString","pairs","pair","existingValue","noOverwrite","combinedParams","valueSet","searchPieces","ServiceClient","createDefaultPipeline","position","afterPhase","endpoint","requestOptions","rawResponse","flatResponse","credentialScopes","getCredentialScopes","credentialOptions","parseCAEChallenge","challenge","keyValue","a","authorizeRequestOnClaimChallenge","parsedChallenge","Constants","isUuid","authorizeRequestOnTenantChallenge","challengeOptions","requestToOptions","getChallenge","challengeInfo","parseChallenge","challengeScopes","buildScopes","extractTenantId","DefaultScopeSuffix","serviceFabricErrorMessage","mapScopesToResource","parseExpirationTimestamp","asNumber","asDate","parseRefreshTimestamp","noCorrelationId","getIdentityClientAuthorityHost","packageDetails","userAgentPrefix","refreshToken","clientSecret","refreshParams","query","urlSuffix","correlationId","controllers","existingOnAbort","unavailableUpn","base64Metadata","appid","upn","tid","oid","Buffer","ClientSecretCredential","newOptions","tokenResponse","EnvironmentCredential","ClientCertificateCredential","ClientAssertionCredential","AzureCliCredential","AzureDeveloperCliCredential","ensureValidScopeForDevTimeCreds","getScopeResource","isLocationDefined","generateMsalBrowserConfiguration","authority","redirectHash","loginStyle","additionallyAllowedTenantIds","msalConfig","disableAutomaticAuthentication","loginHint","app","getApp","handleBrowserResult","msalApp","activeAccount","allAccounts","msalAccount","handleResult","getActiveAccount","login","loginRequest","getTokenSilent","parameters","getTokenInteractive","getToken","getTokenTenantId","InteractiveBrowserCredential","browserOptions","loginStyles","msalOptions","arrayScopes","ManagedIdentityCredential","DeviceCodeCredential","AzurePipelinesCredential","AuthorizationCodeCredential","AzurePowerShellCredential","UsernamePasswordCredential","tenantIdOrName","username","password","webResource","vsCodeCredentialControl","_finder","VisualStudioCodeCredential","OnBehalfOfCredential","WorkloadIdentityCredential","getBearerTokenProvider","tracingOptions","getRefreshedToken","getDefaultAzureCredential"],"sourceRoot":""}